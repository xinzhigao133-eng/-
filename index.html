<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ğŸµ æ­Œè¯æå–å·¥å…·ï¼ˆå¢å¼ºç‰ˆï¼‰</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Noto Sans SC', Arial;
            line-height: 1.6; color: #333;
            background: linear-gradient(135deg,#6a11cb 0%,#2575fc 100%); min-height:100vh; padding:15px;
        }
        .container { max-width:100%; margin:0 auto; background:#fff; border-radius:15px; box-shadow:0 10px 30px rgba(0,0,0,0.2); overflow:hidden; }
        header { background:linear-gradient(135deg,#2c3e50 0%,#3498db 100%); color:#fff; padding:20px 15px; text-align:center; }
        header h1 { font-size:1.8em; margin-bottom:8px; }
        header p { opacity:0.95; }
        .main-content { display:flex; flex-direction:column; }
        .panel { padding:15px; }
        .left-panel { border-bottom:2px solid #f0f0f0; }
        .right-panel { background:#f8f9fa; flex:1; display:flex; flex-direction:column; }
        .section-title { font-size:1.3em; margin-bottom:15px; color:#2c3e50; border-bottom:2px solid #3498db; padding-bottom:10px; display:flex; justify-content:space-between; align-items:center; }
        .file-input-container { margin-bottom:20px; }
        .file-input-label { display:block; margin-bottom:8px; font-weight:600; color:#2c3e50; }
        .file-input { width:100%; padding:12px; border:2px dashed #3498db; border-radius:8px; background:#f8f9fa; font-size:16px; margin-bottom:10px; }
        .table-container { border:1px solid #ddd; border-radius:8px; overflow:auto; margin-bottom:20px; max-height:400px; }
        table { width:100%; border-collapse:collapse; min-width:650px; }
        th { background:#34495e; color:white; padding:12px 8px; text-align:left; position:sticky; top:0; font-size:14px; }
        td { padding:10px 8px; border-bottom:1px solid #eee; font-size:14px; vertical-align:middle; }
        .index-column { width:5%; min-width:40px; text-align:center; }
        .song-name-column { width:30%; min-width:130px; }
        .start-time-column { width:20%; min-width:110px; }
        .duration-column { width:10%; min-width:70px; }
        .action-column { width:15%; min-width:120px; }
        input { width:100%; padding:8px; border:1px solid #ddd; border-radius:4px; font-size:14px; }
        input:focus { outline:none; border-color:#3498db; box-shadow:0 0 5px rgba(52,152,219,0.3); }
        .time-input-group { display:flex; gap:5px; }
        .time-input { flex:1; text-align:center; }
        .time-separator { line-height:35px; }
        .button-group { display:flex; gap:10px; margin-bottom:20px; flex-wrap:wrap; }
        button { padding:12px 16px; border:none; border-radius:6px; cursor:pointer; font-size:14px; font-weight:600; transition:all 0.3s; flex:1; min-width:120px; }
        .btn-primary { background:#3498db; color:#fff; }
        .btn-success { background:#27ae60; color:#fff; }
        .btn-danger { background:#e74c3c; color:#fff; }
        .btn-warning { background:#f39c12; color:#fff; }
        .btn-info { background:#17a2b8; color:#fff; }
        .log-container { flex:1; background:white; border:1px solid #ddd; border-radius:8px; padding:15px; overflow-y:auto; font-family:'Courier New', monospace; font-size:13px; line-height:1.4; min-height:150px; max-height:200px; margin-bottom:15px; }
        .log-entry { margin-bottom:8px; padding:5px; border-radius:3px; }
        .log-success { background:#d4edda; color:#155724; border-left:3px solid #28a745; }
        .log-error { background:#f8d7da; color:#721c24; border-left:3px solid #dc3545; }
        .log-info { background:#d1ecf1; color:#0c5460; border-left:3px solid #17a2b8; }
        .log-warning { background:#fff3cd; color:#856404; border-left:3px solid #ffc107; }
        .instructions { background:#fff3cd; border:1px solid #ffeaa7; border-radius:8px; padding:15px; margin-top:20px; font-size:14px; }
        .file-list { margin-top:15px; }
        .file-item { display:flex; justify-content:space-between; align-items:center; padding:8px; background:#f8f9fa; border-radius:4px; margin-bottom:5px; }
        .file-name { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
        .file-status { font-size:12px; padding:2px 6px; border-radius:3px; margin-left:10px; }
        .status-ready { background:#d4edda; color:#155724; }
        .status-error { background:#f8d7da; color:#721c24; }
        .action-buttons { display:flex; gap:5px; }
        .action-btn { padding:4px 8px; font-size:12px; min-width:auto; flex:none; }
        .progress-bar { width:100%; height:10px; background:#f0f0f0; border-radius:5px; margin:10px 0; overflow:hidden; }
        .progress { height:100%; background:#3498db; width:0%; transition:width 0.3s; }
        .batch-controls { display:flex; gap:10px; margin-bottom:15px; }
        .batch-input { flex:1; padding:8px; border:1px solid #ddd; border-radius:4px; }
        @media (min-width:768px) {
            .main-content { flex-direction:row; }
            .left-panel { flex:1; border-right:2px solid #f0f0f0; border-bottom:none; }
            .right-panel { width:400px; }
        }

        /* --- è‡ªåŠ¨è¡¥å…¨æ ·å¼ --- */
        .autocomplete-list {
            position:absolute;
            border:1px solid #ccc;
            background:#fff;
            z-index:1200;
            max-height:220px;
            overflow-y:auto;
            font-size:14px;
            box-shadow:0 6px 18px rgba(0,0,0,0.12);
        }
        .autocomplete-item { padding:8px 10px; cursor:pointer; }
        .autocomplete-item:hover, .autocomplete-item.active { background:#f1f1f1; }
        
        /* --- æ­Œå•è¾“å…¥æ ·å¼ --- */
        .playlist-container { margin-bottom:20px; }
        .playlist-textarea {
            width:100%;
            padding:12px;
            border:2px dashed #f39c12;
            border-radius:8px;
            background:#fff9e6;
            font-size:14px;
            line-height:1.5;
            resize:vertical;
            min-height:120px;
        }
        .playlist-textarea:focus {
            outline:none;
            border-color:#e67e22;
            box-shadow:0 0 5px rgba(230,126,34,0.3);
        }
        .playlist-help {
            font-size:12px;
            color:#7f8c8d;
            margin-top:5px;
        }

        /* --- é¢„è§ˆé¢æ¿æ ·å¼ï¼ˆé«˜åº¦å¢åŠ ï¼‰ --- */
        .preview-container {
            flex: 1;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
            font-size: 14px;
            line-height: 1.5;
            min-height: 250px;
            max-height: 500px;
        }
        
        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }
        
        .preview-title {
            font-weight: 600;
            color: #2c3e50;
        }
        
        .preview-controls {
            display: flex;
            gap: 8px;
        }
        
        .preview-control-btn {
            padding: 4px 8px;
            font-size: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #f8f9fa;
            cursor: pointer;
        }
        
        .preview-content {
            white-space: pre-wrap;
            font-family: 'Noto Sans SC', Arial, sans-serif;
            min-height: 150px;
        }
        
        .preview-song-title {
            font-weight: 600;
            color: #3498db;
            margin: 12px 0 6px 0;
            padding-bottom: 4px;
            border-bottom: 1px dashed #eee;
        }
        
        .preview-lyric-line {
            margin: 4px 0;
            padding-left: 10px;
        }
        
        .preview-empty {
            text-align: center;
            color: #7f8c8d;
            font-style: italic;
            padding: 20px;
        }
        
        .preview-stats {
            font-size: 12px;
            color: #7f8c8d;
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid #eee;
        }
        
        /* --- å³é”®èœå•æ ·å¼ --- */
        .context-menu {
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            min-width: 180px;
            display: none;
        }
        
        .context-menu-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background 0.2s;
        }
        
        .context-menu-item:last-child {
            border-bottom: none;
        }
        
        .context-menu-item:hover {
            background: #f5f5f5;
        }
        
        /* --- çº é”™å¯¹è¯æ¡†æ ·å¼ --- */
        .correction-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 2000;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow: hidden;
            display: none;
        }
        
        .correction-header {
            background: #3498db;
            color: white;
            padding: 15px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .correction-body {
            padding: 15px;
            max-height: 60vh;
            overflow-y: auto;
        }
        
        .correction-footer {
            padding: 15px;
            background: #f8f9fa;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        .search-results {
            margin-top: 15px;
            border: 1px solid #ddd;
            border-radius: 6px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .search-result-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
        }
        
        .search-result-item:hover {
            background: #f5f5f5;
        }
        
        .search-result-item:last-child {
            border-bottom: none;
        }
        
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1500;
            display: none;
        }
        
        /* --- ä¿å­˜çŠ¶æ€æŒ‡ç¤ºå™¨ --- */
        .save-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 5px;
            background: #28a745;
            color: white;
            font-size: 14px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
        }
        
        /* --- é¡¹ç›®æ–‡ä»¶æ“ä½œæŒ‰é’® --- */
        .project-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .project-btn {
            flex: 1;
            padding: 10px;
            font-size: 14px;
        }
        
        /* --- æœç´¢æ¡†æ ·å¼ --- */
        .search-container {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }
        
        .search-input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .search-button {
            padding: 8px 16px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .search-button:hover {
            background: #2980b9;
        }
        
        .search-results-count {
            font-size: 12px;
            color: #7f8c8d;
            margin-left: 10px;
        }
        
        /* --- æœç´¢ç»“æœé«˜äº® --- */
        .search-highlight {
            background-color: #fff3cd;
            padding: 2px 4px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸµ æ­Œè¯æå–å·¥å…·ï¼ˆå¢å¼ºç‰ˆï¼‰</h1>
            <p>ä» LRC æ–‡ä»¶ä¸­æå–æŒ‡å®šæ—¶é—´æ®µçš„æ­Œè¯ï¼ˆæ”¯æŒ ZIP æ‰¹é‡ï¼‰</p>
        </header>

        <div class="main-content">
            <div class="panel left-panel">
                <div class="section-title">
                    <span>ä¸Šä¼ æ–‡ä»¶</span>
                    <div class="search-container">
                        <input type="text" id="searchInput" class="search-input" placeholder="æœç´¢æ­Œæ›²...">
                        <button class="search-button" onclick="searchSongs()">æœç´¢</button>
                        <span id="searchResultsCount" class="search-results-count"></span>
                    </div>
                </div>
                
                <div class="file-input-container">
                    <label class="file-input-label">é€‰æ‹© LRC æ–‡ä»¶æˆ– ZIP å‹ç¼©åŒ…ï¼š</label>
                    <input type="file" id="lrcFiles" accept=".lrc,.zip" multiple class="file-input">
                    <small>æ”¯æŒå•ä¸ª .lrcã€å¤šä¸ª .lrc æˆ–åŒ…å« LRC æ–‡ä»¶çš„ ZIP å‹ç¼©åŒ…</small>
                </div>

                <div id="fileList" class="file-list"></div>

                <h2 class="section-title" style="margin-top:20px;">æ­Œå•é¡ºåºè®¾ç½®</h2>
                
                <div class="playlist-container">
                    <textarea id="playlistInput" class="playlist-textarea" placeholder="è¯·åœ¨æ­¤è¾“å…¥æ‚¨çš„æ­Œå•é¡ºåºï¼Œæ¯è¡Œä¸€é¦–æ­Œåï¼ˆç¤ºä¾‹ï¼‰ï¼š
å¯Œå£«å±±ä¸‹
çˆ±æƒ…è½¬ç§»
çº¢ç«ç‘°
..."></textarea>
                    <div class="playlist-help">æ¯è¡Œè¾“å…¥ä¸€é¦–æ­Œæ›²åç§°ï¼Œç³»ç»Ÿå°†ä¸¥æ ¼æŒ‰ç…§æ­¤é¡ºåºå¡«å……æ­Œæ›²åˆ—è¡¨</div>
                </div>

                <h2 class="section-title">æ­Œæ›²åˆ—è¡¨ç¼–è¾‘</h2>

                <div class="batch-controls">
                    <div style="flex:1; display:flex; gap:10px;">
                        <input type="number" id="batchMinutes" class="batch-input" placeholder="æ‰¹é‡è®¾ç½®åˆ†é’Ÿ" min="0">
                        <input type="number" id="batchSeconds" class="batch-input" placeholder="æ‰¹é‡è®¾ç½®ç§’æ•°" min="0" max="59">
                    </div>
                    <input type="number" id="batchDuration" class="batch-input" placeholder="æ‰¹é‡è®¾ç½®æŒç»­æ—¶é—´(ç§’)" min="1" value="10">
                    <button class="btn-primary action-btn" onclick="applyBatchSettings()">åº”ç”¨</button>
                </div>

                <div class="table-container">
                    <table id="songsTable">
                        <thead>
                            <tr>
                                <th class="index-column">åºå·</th>
                                <th class="song-name-column">æ­Œæ›²åç§°</th>
                                <th class="start-time-column">å¼€å§‹æ—¶é—´</th>
                                <th class="duration-column">æŒç»­æ—¶é—´(ç§’)</th>
                                <th class="action-column">æ“ä½œ</th>
                            </tr>
                        </thead>
                        <tbody id="songsTableBody"></tbody>
                    </table>
                </div>

                <div class="button-group">
                    <button class="btn-warning" onclick="fillSongsByPlaylist()">æŒ‰æ­Œå•é¡ºåºå¡«å……</button>
                    <button class="btn-primary" onclick="autoFillSongs()">æŒ‰æ–‡ä»¶åå¡«å……</button>
                    <button class="btn-warning" onclick="addSongRow()">æ·»åŠ æ­Œæ›²</button>
                    <button class="btn-success" onclick="processSongs()">å¼€å§‹å¤„ç†</button>
                    <button class="btn-info" onclick="saveProgress()">ä¿å­˜è¿›åº¦</button>
                    <button class="btn-info" onclick="loadProgress()">åŠ è½½è¿›åº¦</button>
                    <button class="btn-danger" onclick="clearAll()">æ¸…ç©ºå…¨éƒ¨</button>
                </div>

                <div class="project-buttons">
                    <button class="btn-primary project-btn" onclick="exportProject()">å¯¼å‡ºé¡¹ç›®æ–‡ä»¶</button>
                    <button class="btn-success project-btn" onclick="importProject()">å¯¼å…¥é¡¹ç›®æ–‡ä»¶</button>
                </div>

                <div class="progress-bar">
                    <div class="progress" id="progressBar"></div>
                </div>

                <div class="instructions">
                    <h3>ä½¿ç”¨è¯´æ˜ï¼š</h3>
                    <p>1. ä¸Šä¼  LRC æ–‡ä»¶æˆ– ZIP å‹ç¼©åŒ…ï¼ˆæ”¯æŒå¤šæ–‡ä»¶ï¼‰</p>
                    <p>2. åœ¨"æ­Œå•é¡ºåºè®¾ç½®"ä¸­è¾“å…¥æ‚¨çš„æ­Œå•ï¼ˆæ¯è¡Œä¸€é¦–æ­Œåï¼‰</p>
                    <p>3. ç‚¹å‡»"æŒ‰æ­Œå•é¡ºåºå¡«å……"ä¸¥æ ¼æŒ‰ç…§æ­Œå•é¡ºåºå¡«å……æ­Œæ›²åˆ—è¡¨</p>
                    <p>4. åœ¨"æ­Œæ›²åç§°"è¾“å…¥æ—¶ä¼šæ ¹æ®ä¸Šä¼ çš„æ‰€æœ‰æ–‡ä»¶åè”æƒ³å»ºè®®ï¼ˆæ”¯æŒä¸Šä¸‹é”®å’Œå›è½¦ï¼‰</p>
                    <p>5. ä½¿ç”¨å³ä¸Šè§’æœç´¢æ¡†å¯ä»¥å¿«é€Ÿæœç´¢å’Œå®šä½æ­Œæ›²</p>
                    <p>6. å³é”®ç‚¹å‡»æ­Œæ›²è¡Œå¯è¿›è¡Œçº é”™æ“ä½œ</p>
                    <p>7. è®¾ç½®å¼€å§‹æ—¶é—´ä¸æŒç»­æ—¶é—´ï¼Œç‚¹å‡»"å¼€å§‹å¤„ç†"ç”Ÿæˆ Word æ–‡æ¡£</p>
                    <p>8. ä½¿ç”¨"ä¿å­˜è¿›åº¦"ä¿å­˜å½“å‰å·¥ä½œçŠ¶æ€ï¼Œä¸‹æ¬¡å¯"åŠ è½½è¿›åº¦"ç»§ç»­å¤„ç†</p>
                    <p>9. å³ä¾§é¢„è§ˆé¢æ¿ä¼šå®æ—¶æ˜¾ç¤ºå°†è¦æå–çš„æ­Œè¯å†…å®¹</p>
                    <p>10. ä½¿ç”¨"å¯¼å‡ºé¡¹ç›®æ–‡ä»¶"ä¿å­˜å®Œæ•´å·¥ä½œçŠ¶æ€åˆ°.lyricprojectæ–‡ä»¶</p>
                    <p>11. ä½¿ç”¨"å¯¼å…¥é¡¹ç›®æ–‡ä»¶"ä».lyricprojectæ–‡ä»¶æ¢å¤å®Œæ•´å·¥ä½œçŠ¶æ€</p>
                </div>
            </div>

            <div class="panel right-panel">
                <h2 class="section-title">å¤„ç†æ—¥å¿—</h2>
                <div class="log-container" id="logContainer">
                    <div class="log-entry log-info">æ¬¢è¿ä½¿ç”¨æ­Œè¯æå–å·¥å…·å¢å¼ºç‰ˆï¼æ”¯æŒå‹ç¼©åŒ…ä¸Šä¼ ã€æ­Œå•é¡ºåºå¡«å……å’Œå³é”®çº é”™ã€‚</div>
                </div>
                
                <h2 class="section-title">è¾“å‡ºé¢„è§ˆ</h2>
                <div class="preview-container">
                    <div class="preview-header">
                        <div class="preview-title">å®æ—¶é¢„è§ˆ</div>
                        <div class="preview-controls">
                            <button class="preview-control-btn" onclick="refreshPreview()">ğŸ”„ åˆ·æ–°</button>
                            <button class="preview-control-btn" onclick="clearPreview()">ğŸ—‘ï¸ æ¸…ç©º</button>
                        </div>
                    </div>
                    <div class="preview-content" id="previewContent">
                        <div class="preview-empty">æš‚æ— é¢„è§ˆå†…å®¹<br>è¯·å…ˆä¸Šä¼ æ–‡ä»¶å¹¶è®¾ç½®æ­Œæ›²å‚æ•°</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ä¿å­˜çŠ¶æ€æŒ‡ç¤ºå™¨ -->
    <div class="save-status" id="saveStatus"></div>

    <!-- å³é”®èœå• -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" onclick="showCorrectionDialog()">çº é”™åŒ¹é…</div>
        <div class="context-menu-item" onclick="rematchCurrentSong()">é‡æ–°åŒ¹é…æ­¤æ­Œæ›²</div>
        <div class="context-menu-item" onclick="copySongName()">å¤åˆ¶æ­Œæ›²åç§°</div>
        <div class="context-menu-item" onclick="insertRowBelow()">åœ¨ä¸‹æ–¹æ’å…¥è¡Œ</div>
    </div>

    <!-- çº é”™å¯¹è¯æ¡† -->
    <div class="overlay" id="overlay"></div>
    <div class="correction-dialog" id="correctionDialog">
        <div class="correction-header">
            <span>æ­Œæ›²åŒ¹é…çº é”™</span>
            <button style="background:none;border:none;color:white;cursor:pointer;font-size:16px;" onclick="closeCorrectionDialog()">Ã—</button>
        </div>
        <div class="correction-body">
            <div id="currentMatchInfo">
                <p><strong>å½“å‰åŒ¹é…:</strong> <span id="currentSongName"></span></p>
            </div>
            <div style="margin-top:15px;">
                <p><strong>æœç´¢æ­£ç¡®æ­Œæ›²:</strong></p>
                <input type="text" id="searchCorrectionInput" style="width:100%;padding:8px;margin:8px 0;" placeholder="è¾“å…¥æ­Œæ›²åç§°æœç´¢">
                <button class="btn-primary" onclick="searchSongsForCorrection()" style="width:100%;">æœç´¢</button>
            </div>
            <div class="search-results" id="searchCorrectionResults" style="display:none;">
                <!-- æœç´¢ç»“æœå°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
            </div>
        </div>
        <div class="correction-footer">
            <button class="btn-danger" onclick="closeCorrectionDialog()">å–æ¶ˆ</button>
        </div>
    </div>

    <script>
        // --- å…¨å±€çŠ¶æ€ ---
        let lrcFiles = {};   // { fileNameNoExt: {name, content, source} }
        let songRows = [];   // [{id, songName, minutes, seconds, duration}]
        let AUTOCOMPLETE_MAX = 8;
        let previewUpdateTimer = null;
        let currentContextRowId = null;
        let autoSaveTimer = null;

        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('lrcFiles').addEventListener('change', handleFileUpload);
            // é»˜è®¤åˆ›å»º 3 è¡Œå¯ç¼–è¾‘è¡Œ
            for (let i = 0; i < 3; i++) addSongRow();
            updateIndexes();
            
            // ç›‘å¬è¾“å…¥å˜åŒ–ï¼Œå®æ—¶æ›´æ–°é¢„è§ˆ
            setupRealTimePreview();
            
            // ç‚¹å‡»é¡µé¢å…¶ä»–åœ°æ–¹å…³é—­å³é”®èœå•
            document.addEventListener('click', function() {
                document.getElementById('contextMenu').style.display = 'none';
            });
            
            // å°è¯•è‡ªåŠ¨åŠ è½½ä¸Šæ¬¡ä¿å­˜çš„è¿›åº¦
            tryAutoLoadProgress();
            
            // æœç´¢æ¡†å›è½¦äº‹ä»¶
            document.getElementById('searchInput').addEventListener('keyup', function(e) {
                if (e.key === 'Enter') {
                    searchSongs();
                }
            });
        });

        // --- æœç´¢åŠŸèƒ½ ---
        function searchSongs() {
            const query = document.getElementById('searchInput').value.trim().toLowerCase();
            if (!query) {
                // æ¸…ç©ºæœç´¢ï¼Œæ˜¾ç¤ºæ‰€æœ‰è¡Œ
                const allRows = document.querySelectorAll('#songsTableBody tr');
                allRows.forEach(row => {
                    row.style.display = '';
                });
                document.getElementById('searchResultsCount').textContent = '';
                return;
            }
            
            let matchCount = 0;
            const allRows = document.querySelectorAll('#songsTableBody tr');
            
            allRows.forEach(row => {
                const songInput = row.querySelector('.song-input');
                if (songInput) {
                    const songName = songInput.value.toLowerCase();
                    if (songName.includes(query)) {
                        row.style.display = '';
                        matchCount++;
                    } else {
                        row.style.display = 'none';
                    }
                }
            });
            
            document.getElementById('searchResultsCount').textContent = `æ‰¾åˆ° ${matchCount} ä¸ªåŒ¹é…é¡¹`;
            
            if (matchCount === 0) {
                addLog(`æœªæ‰¾åˆ°åŒ…å«"${query}"çš„æ­Œæ›²`, 'warning');
            } else {
                addLog(`æ‰¾åˆ° ${matchCount} ä¸ªåŒ…å«"${query}"çš„æ­Œæ›²`, 'info');
            }
        }

        // --- é¡¹ç›®æ–‡ä»¶å¯¼å‡º/å¯¼å…¥åŠŸèƒ½ ---
        function exportProject() {
            try {
                // æ”¶é›†æ‰€æœ‰éœ€è¦ä¿å­˜çš„æ•°æ®
                const projectData = {
                    version: "1.0",
                    timestamp: new Date().toISOString(),
                    songRows: songRows.map(row => ({
                        songName: row.songName,
                        minutes: row.minutes,
                        seconds: row.seconds,
                        duration: row.duration
                    })),
                    playlist: document.getElementById('playlistInput').value,
                    batchMinutes: document.getElementById('batchMinutes').value,
                    batchSeconds: document.getElementById('batchSeconds').value,
                    batchDuration: document.getElementById('batchDuration').value,
                    lrcFiles: {}
                };
                
                // å°†æ­Œè¯æ–‡ä»¶å†…å®¹è½¬æ¢ä¸ºBase64å¹¶ä¿å­˜
                for (const fileName in lrcFiles) {
                    if (lrcFiles.hasOwnProperty(fileName)) {
                        const fileData = lrcFiles[fileName];
                        // å°†æ–‡æœ¬å†…å®¹è½¬æ¢ä¸ºBase64
                        const base64Content = btoa(unescape(encodeURIComponent(fileData.content)));
                        projectData.lrcFiles[fileName] = {
                            name: fileData.name,
                            content: base64Content,
                            source: fileData.source
                        };
                    }
                }
                
                // åˆ›å»ºé¡¹ç›®æ–‡ä»¶
                const projectBlob = new Blob([JSON.stringify(projectData, null, 2)], { 
                    type: 'application/json' 
                });
                const url = URL.createObjectURL(projectBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `lyrics_project_${new Date().toISOString().slice(0,10)}.lyricproject`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                addLog('é¡¹ç›®æ–‡ä»¶å·²å¯¼å‡º', 'success');
                showSaveStatus('é¡¹ç›®æ–‡ä»¶å·²å¯¼å‡º', 'success');
            } catch (error) {
                addLog('å¯¼å‡ºé¡¹ç›®æ–‡ä»¶å¤±è´¥: ' + error.message, 'error');
                showSaveStatus('å¯¼å‡ºå¤±è´¥', 'error');
            }
        }
        
        function importProject() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.lyricproject';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const projectData = JSON.parse(event.target.result);
                        
                        // éªŒè¯é¡¹ç›®æ–‡ä»¶æ ¼å¼
                        if (!projectData.lrcFiles || !projectData.songRows) {
                            throw new Error('æ— æ•ˆçš„é¡¹ç›®æ–‡ä»¶æ ¼å¼');
                        }
                        
                        // æ¸…ç©ºç°æœ‰æ•°æ®
                        clearAll();
                        
                        // æ¢å¤æ­Œè¯æ–‡ä»¶
                        lrcFiles = {};
                        for (const fileName in projectData.lrcFiles) {
                            if (projectData.lrcFiles.hasOwnProperty(fileName)) {
                                const fileData = projectData.lrcFiles[fileName];
                                // å°†Base64å†…å®¹è½¬æ¢å›æ–‡æœ¬
                                const textContent = decodeURIComponent(escape(atob(fileData.content)));
                                lrcFiles[fileName] = {
                                    name: fileData.name,
                                    content: textContent,
                                    source: fileData.source
                                };
                            }
                        }
                        
                        // æ¢å¤æ­Œå•
                        document.getElementById('playlistInput').value = projectData.playlist || '';
                        
                        // æ¢å¤æ‰¹é‡è®¾ç½®
                        document.getElementById('batchMinutes').value = projectData.batchMinutes || '';
                        document.getElementById('batchSeconds').value = projectData.batchSeconds || '';
                        document.getElementById('batchDuration').value = projectData.batchDuration || '10';
                        
                        // æ¢å¤æ­Œæ›²åˆ—è¡¨
                        if (projectData.songRows && projectData.songRows.length > 0) {
                            projectData.songRows.forEach(song => {
                                addSongRow(
                                    song.songName || '',
                                    song.minutes || '',
                                    song.seconds || '',
                                    song.duration || 10
                                );
                            });
                        }
                        
                        // æ›´æ–°æ–‡ä»¶åˆ—è¡¨æ˜¾ç¤º
                        updateFileListDisplay();
                        
                        addLog(`é¡¹ç›®æ–‡ä»¶å·²å¯¼å…¥ï¼Œæ¢å¤ ${Object.keys(lrcFiles).length} ä¸ªæ­Œè¯æ–‡ä»¶å’Œ ${projectData.songRows.length} é¦–æ­Œæ›²`, 'success');
                        showSaveStatus('é¡¹ç›®æ–‡ä»¶å·²å¯¼å…¥', 'success');
                        
                        // æ›´æ–°é¢„è§ˆ
                        updatePreview();
                        
                    } catch (error) {
                        addLog('å¯¼å…¥é¡¹ç›®æ–‡ä»¶å¤±è´¥: ' + error.message, 'error');
                        showSaveStatus('å¯¼å…¥å¤±è´¥', 'error');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        function updateFileListDisplay() {
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = '';
            
            for (const fileName in lrcFiles) {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.innerHTML = `
                    <div class="file-name">${lrcFiles[fileName].source || fileName}</div>
                    <div class="file-status status-ready">å·²å¯¼å…¥</div>
                `;
                fileList.appendChild(fileItem);
            }
        }

        // --- æ’å…¥è¡ŒåŠŸèƒ½ ---
        function insertRowBelow() {
            if (!currentContextRowId) return;
            
            const currentIndex = songRows.findIndex(r => r.id === currentContextRowId);
            if (currentIndex === -1) return;
            
            // åˆ›å»ºæ–°è¡Œå¹¶æ’å…¥åˆ°å½“å‰è¡Œåé¢
            const newRowId = addSongRowAtPosition(currentIndex + 1);
            
            addLog('å·²åœ¨å½“å‰è¡Œä¸‹æ–¹æ’å…¥æ–°è¡Œ', 'info');
            document.getElementById('contextMenu').style.display = 'none';
        }
        
        function addSongRowAtPosition(position, songName = '', minutes = '', seconds = '', duration = 10) {
            const tbody = document.getElementById('songsTableBody');
            const rowId = 'row_' + Date.now() + '_' + Math.random().toString(36).substr(2,9);
            
            // åˆ›å»ºæ–°è¡Œ
            const row = document.createElement('tr');
            row.id = rowId;
            row.innerHTML = `
                <td class="index-column index-cell">${position + 1}</td>
                <td class="song-name-column">
                    <input type="text" class="song-input" value="${escapeHtml(songName)}" placeholder="è¾“å…¥æ­Œæ›²åç§°">
                </td>
                <td class="start-time-column">
                    <div class="time-input-group">
                        <input type="number" class="minute-input time-input" value="${minutes}" placeholder="åˆ†" min="0">
                        <span class="time-separator">:</span>
                        <input type="number" class="second-input time-input" value="${seconds}" placeholder="ç§’" min="0" max="59">
                    </div>
                </td>
                <td class="duration-column"><input type="number" class="duration-input" value="${duration}" step="0.1" min="1"></td>
                <td class="action-column">
                    <div class="action-buttons">
                        <button class="btn-primary action-btn" onclick="insertRowAt('${rowId}')">æ’å…¥</button>
                        <button class="btn-danger action-btn" type="button">åˆ é™¤</button>
                    </div>
                </td>
            `;
            
            // æ’å…¥åˆ°æŒ‡å®šä½ç½®
            if (position >= tbody.children.length) {
                tbody.appendChild(row);
            } else {
                tbody.insertBefore(row, tbody.children[position]);
            }
            
            // ä¿å­˜åˆ° songRows
            songRows.splice(position, 0, {
                id: rowId,
                songName: songName,
                minutes: minutes,
                seconds: seconds,
                duration: duration
            });
            
            // ç»‘å®šäº‹ä»¶
            const songInput = row.querySelector('.song-input');
            const minuteInput = row.querySelector('.minute-input');
            const secondInput = row.querySelector('.second-input');
            const durationInput = row.querySelector('.duration-input');
            const delBtn = row.querySelector('.action-btn.btn-danger');
            
            songInput.addEventListener('input', () => {
                updateSongRow(rowId);
                schedulePreviewUpdate();
            });
            minuteInput.addEventListener('input', () => {
                updateSongRow(rowId);
                schedulePreviewUpdate();
            });
            secondInput.addEventListener('input', () => {
                updateSongRow(rowId);
                schedulePreviewUpdate();
            });
            durationInput.addEventListener('input', () => {
                updateSongRow(rowId);
                schedulePreviewUpdate();
            });
            delBtn.addEventListener('click', () => deleteSongRow(rowId));
            
            // å³é”®èœå•äº‹ä»¶
            row.addEventListener('contextmenu', (e) => showContextMenu(e, rowId));
            
            // ç»‘å®šè‡ªåŠ¨è¡¥å…¨
            setupAutoComplete(songInput, () => Object.keys(lrcFiles), rowId);
            
            updateIndexes();
            return rowId;
        }
        
        function insertRowAt(rowId) {
            const currentIndex = songRows.findIndex(r => r.id === rowId);
            if (currentIndex === -1) return;
            
            addSongRowAtPosition(currentIndex + 1);
            addLog('å·²åœ¨æŒ‡å®šè¡Œä¸‹æ–¹æ’å…¥æ–°è¡Œ', 'info');
        }

        // --- æœ¬åœ°ä¿å­˜åŠŸèƒ½ ---
        function saveProgress() {
            try {
                const progressData = {
                    songRows: songRows.map(row => ({
                        songName: row.songName,
                        minutes: row.minutes,
                        seconds: row.seconds,
                        duration: row.duration
                    })),
                    playlist: document.getElementById('playlistInput').value,
                    batchMinutes: document.getElementById('batchMinutes').value,
                    batchSeconds: document.getElementById('batchSeconds').value,
                    batchDuration: document.getElementById('batchDuration').value,
                    timestamp: new Date().toISOString()
                };
                
                localStorage.setItem('lyricExtractorProgress', JSON.stringify(progressData));
                showSaveStatus('è¿›åº¦å·²ä¿å­˜', 'success');
                addLog('è¿›åº¦å·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨', 'success');
            } catch (error) {
                showSaveStatus('ä¿å­˜å¤±è´¥', 'error');
                addLog('ä¿å­˜è¿›åº¦å¤±è´¥: ' + error.message, 'error');
            }
        }
        
        function loadProgress() {
            try {
                const savedData = localStorage.getItem('lyricExtractorProgress');
                if (!savedData) {
                    addLog('æ²¡æœ‰æ‰¾åˆ°å·²ä¿å­˜çš„è¿›åº¦', 'warning');
                    return;
                }
                
                const progressData = JSON.parse(savedData);
                
                // æ¸…ç©ºç°æœ‰è¡¨æ ¼
                const tbody = document.getElementById('songsTableBody');
                tbody.innerHTML = '';
                songRows = [];
                
                // æ¢å¤æ­Œå•
                document.getElementById('playlistInput').value = progressData.playlist || '';
                
                // æ¢å¤æ‰¹é‡è®¾ç½®
                document.getElementById('batchMinutes').value = progressData.batchMinutes || '';
                document.getElementById('batchSeconds').value = progressData.batchSeconds || '';
                document.getElementById('batchDuration').value = progressData.batchDuration || '10';
                
                // æ¢å¤æ­Œæ›²åˆ—è¡¨
                if (progressData.songRows && progressData.songRows.length > 0) {
                    progressData.songRows.forEach(song => {
                        addSongRow(
                            song.songName || '',
                            song.minutes || '',
                            song.seconds || '',
                            song.duration || 10
                        );
                    });
                    addLog(`å·²åŠ è½½ ${progressData.songRows.length} é¦–æ­Œæ›²`, 'success');
                } else {
                    addLog('å·²åŠ è½½è¿›åº¦ï¼Œä½†æ²¡æœ‰æ­Œæ›²æ•°æ®', 'info');
                }
                
                showSaveStatus('è¿›åº¦å·²åŠ è½½', 'success');
                
                // æ›´æ–°é¢„è§ˆ
                updatePreview();
                
            } catch (error) {
                addLog('åŠ è½½è¿›åº¦å¤±è´¥: ' + error.message, 'error');
                showSaveStatus('åŠ è½½å¤±è´¥', 'error');
            }
        }
        
        function tryAutoLoadProgress() {
            // æ£€æŸ¥æ˜¯å¦æœ‰ä¿å­˜çš„è¿›åº¦
            const savedData = localStorage.getItem('lyricExtractorProgress');
            if (savedData) {
                addLog('æ£€æµ‹åˆ°æœ‰ä¿å­˜çš„è¿›åº¦ï¼Œç‚¹å‡»"åŠ è½½è¿›åº¦"æŒ‰é’®å¯æ¢å¤', 'info');
            }
        }
        
        function showSaveStatus(message, type) {
            const status = document.getElementById('saveStatus');
            status.textContent = message;
            status.style.display = 'block';
            status.style.background = type === 'success' ? '#28a745' : '#dc3545';
            
            setTimeout(() => {
                status.style.display = 'none';
            }, 3000);
        }
        
        // è‡ªåŠ¨ä¿å­˜åŠŸèƒ½ï¼ˆæ¯30ç§’è‡ªåŠ¨ä¿å­˜ä¸€æ¬¡ï¼‰
        function setupAutoSave() {
            // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
            }
            
            // è®¾ç½®æ–°çš„å®šæ—¶å™¨
            autoSaveTimer = setInterval(() => {
                if (songRows.length > 0) {
                    saveProgress();
                }
            }, 30000); // 30ç§’è‡ªåŠ¨ä¿å­˜ä¸€æ¬¡
        }

        // --- å³é”®èœå•åŠŸèƒ½ ---
        function showContextMenu(event, rowId) {
            event.preventDefault();
            currentContextRowId = rowId;
            
            const menu = document.getElementById('contextMenu');
            menu.style.display = 'block';
            menu.style.left = event.pageX + 'px';
            menu.style.top = event.pageY + 'px';
        }
        
        function showCorrectionDialog() {
            if (!currentContextRowId) return;
            
            const row = songRows.find(r => r.id === currentContextRowId);
            if (!row) return;
            
            document.getElementById('currentSongName').textContent = row.songName || 'æœªå‘½åæ­Œæ›²';
            document.getElementById('correctionDialog').style.display = 'block';
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('contextMenu').style.display = 'none';
        }
        
        function closeCorrectionDialog() {
            document.getElementById('correctionDialog').style.display = 'none';
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('searchCorrectionResults').style.display = 'none';
            document.getElementById('searchCorrectionInput').value = '';
        }
        
        function searchSongsForCorrection() {
            const query = document.getElementById('searchCorrectionInput').value.trim();
            if (!query) return;
            
            const resultsContainer = document.getElementById('searchCorrectionResults');
            resultsContainer.innerHTML = '';
            
            // æœç´¢åŒ¹é…çš„æ­Œæ›²
            const matches = [];
            for (const fileName in lrcFiles) {
                if (fileName.toLowerCase().includes(query.toLowerCase())) {
                    matches.push(fileName);
                }
            }
            
            if (matches.length === 0) {
                resultsContainer.innerHTML = '<div style="padding:15px;text-align:center;color:#7f8c8d;">æœªæ‰¾åˆ°åŒ¹é…çš„æ­Œæ›²</div>';
            } else {
                matches.forEach(match => {
                    const item = document.createElement('div');
                    item.className = 'search-result-item';
                    item.textContent = match;
                    item.onclick = function() {
                        // æ›´æ–°å½“å‰è¡Œçš„æ­Œæ›²åç§°
                        const rowIndex = songRows.findIndex(r => r.id === currentContextRowId);
                        if (rowIndex !== -1) {
                            songRows[rowIndex].songName = match;
                            document.querySelector(`#${currentContextRowId} .song-input`).value = match;
                            addLog(`å·²æ›´æ­£æ­Œæ›²ä¸º: ${match}`, 'success');
                            schedulePreviewUpdate();
                        }
                        closeCorrectionDialog();
                    };
                    resultsContainer.appendChild(item);
                });
            }
            
            resultsContainer.style.display = 'block';
        }
        
        function rematchCurrentSong() {
            if (!currentContextRowId) return;
            
            const row = songRows.find(r => r.id === currentContextRowId);
            if (!row || !row.songName) return;
            
            // æŸ¥æ‰¾åŒ¹é…çš„LRCæ–‡ä»¶
            const matchedFiles = [];
            for (const fileName in lrcFiles) {
                if (fuzzyMatch(row.songName, fileName)) {
                    matchedFiles.push(fileName);
                }
            }
            
            if (matchedFiles.length === 0) {
                addLog(`æœªæ‰¾åˆ°åŒ¹é…çš„æ­Œè¯æ–‡ä»¶: ${row.songName}`, 'error');
            } else if (matchedFiles.length === 1) {
                addLog(`å·²é‡æ–°åŒ¹é…åˆ°: ${matchedFiles[0]}`, 'success');
            } else {
                addLog(`æ‰¾åˆ°å¤šä¸ªåŒ¹é…æ–‡ä»¶ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ª: ${matchedFiles[0]} (å…±${matchedFiles.length}ä¸ª)`, 'info');
            }
            
            document.getElementById('contextMenu').style.display = 'none';
        }
        
        function copySongName() {
            if (!currentContextRowId) return;
            
            const row = songRows.find(r => r.id === currentContextRowId);
            if (!row || !row.songName) return;
            
            navigator.clipboard.writeText(row.songName).then(function() {
                addLog(`å·²å¤åˆ¶æ­Œæ›²åç§°: ${row.songName}`, 'success');
            }, function() {
                addLog('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶', 'error');
            });
            
            document.getElementById('contextMenu').style.display = 'none';
        }

        // --- å®æ—¶é¢„è§ˆåŠŸèƒ½ ---
        function setupRealTimePreview() {
            // ç›‘å¬æ­Œæ›²è¡¨æ ¼ä¸­çš„è¾“å…¥å˜åŒ–
            document.addEventListener('input', function(e) {
                if (e.target.classList.contains('song-input') || 
                    e.target.classList.contains('minute-input') || 
                    e.target.classList.contains('second-input') || 
                    e.target.classList.contains('duration-input')) {
                    schedulePreviewUpdate();
                }
            });
            
            // ç›‘å¬æ‰¹é‡è®¾ç½®å˜åŒ–
            document.getElementById('batchMinutes').addEventListener('input', schedulePreviewUpdate);
            document.getElementById('batchSeconds').addEventListener('input', schedulePreviewUpdate);
            document.getElementById('batchDuration').addEventListener('input', schedulePreviewUpdate);
            
            // ç›‘å¬æ­Œå•è¾“å…¥å˜åŒ–
            document.getElementById('playlistInput').addEventListener('input', schedulePreviewUpdate);
            
            // å¯åŠ¨è‡ªåŠ¨ä¿å­˜
            setupAutoSave();
        }
        
        function schedulePreviewUpdate() {
            // ä½¿ç”¨é˜²æŠ–æŠ€æœ¯ï¼Œé¿å…é¢‘ç¹æ›´æ–°é¢„è§ˆ
            if (previewUpdateTimer) {
                clearTimeout(previewUpdateTimer);
            }
            previewUpdateTimer = setTimeout(updatePreview, 500);
        }
        
        function updatePreview() {
            if (Object.keys(lrcFiles).length === 0 || songRows.length === 0) {
                showPreviewEmpty();
                return;
            }
            
            let previewContent = '';
            let totalLyrics = 0;
            let processedSongs = 0;
            
            const validRows = songRows.filter(s => s.songName && s.songName.trim());
            
            if (validRows.length === 0) {
                showPreviewEmpty();
                return;
            }
            
            for (let i = 0; i < validRows.length; i++) {
                const song = validRows[i];
                // å¤„ç†ç©ºå€¼æƒ…å†µï¼Œç©ºå­—ç¬¦ä¸²è§†ä¸º0
                const minutes = song.minutes === '' ? 0 : parseInt(song.minutes) || 0;
                const seconds = song.seconds === '' ? 0 : parseInt(song.seconds) || 0;
                const startTime = minutes * 60 + seconds;
                
                // æ‰¾åˆ°åŒ¹é…çš„æ–‡ä»¶å
                const matchedFiles = [];
                for (const fileName in lrcFiles) {
                    if (fuzzyMatch(song.songName, fileName)) {
                        matchedFiles.push(fileName);
                    }
                }
                
                if (matchedFiles.length === 0) {
                    previewContent += `<div class="preview-song-title">${escapeHtml(song.songName)}</div>`;
                    previewContent += `<div class="preview-lyric-line" style="color:#e74c3c;">âŒ æœªæ‰¾åˆ°åŒ¹é…çš„æ­Œè¯æ–‡ä»¶</div>`;
                    continue;
                }
                
                const matchedFile = lrcFiles[matchedFiles[0]];
                const result = extractLyrics(matchedFile.content, song.songName, startTime, song.duration);
                
                previewContent += `<div class="preview-song-title">${escapeHtml(song.songName)}</div>`;
                
                if (result.success && result.lyrics.length > 0) {
                    result.lyrics.forEach(lyric => {
                        previewContent += `<div class="preview-lyric-line">${escapeHtml(lyric)}</div>`;
                    });
                    totalLyrics += result.lyrics.length;
                    processedSongs++;
                } else {
                    previewContent += `<div class="preview-lyric-line" style="color:#f39c12;">âš ï¸ è¯¥æ—¶é—´æ®µå†…æœªæ‰¾åˆ°æ­Œè¯</div>`;
                }
                
                // æ·»åŠ æ­Œæ›²é—´åˆ†éš”
                if (i < validRows.length - 1) {
                    previewContent += `<div style="margin:10px 0; border-top:1px dashed #eee;"></div>`;
                }
            }
            
            const stats = `<div class="preview-stats">å…± ${processedSongs} é¦–æ­Œæ›²ï¼Œ${totalLyrics} è¡Œæ­Œè¯</div>`;
            
            document.getElementById('previewContent').innerHTML = previewContent + stats;
        }
        
        function showPreviewEmpty() {
            document.getElementById('previewContent').innerHTML = 
                '<div class="preview-empty">æš‚æ— é¢„è§ˆå†…å®¹<br>è¯·å…ˆä¸Šä¼ æ–‡ä»¶å¹¶è®¾ç½®æ­Œæ›²å‚æ•°</div>';
        }
        
        function refreshPreview() {
            updatePreview();
            addLog('é¢„è§ˆå·²åˆ·æ–°', 'info');
        }
        
        function clearPreview() {
            showPreviewEmpty();
            addLog('é¢„è§ˆå·²æ¸…ç©º', 'info');
        }

        // ---------- æ–°å¢åŠŸèƒ½ï¼šæŒ‰æ­Œå•é¡ºåºå¡«å…… ----------
        function fillSongsByPlaylist() {
            const playlistText = document.getElementById('playlistInput').value.trim();
            if (!playlistText) {
                addLog('è¯·åœ¨æ­Œå•è¾“å…¥æ¡†ä¸­è¾“å…¥æ­Œæ›²é¡ºåº', 'error');
                return;
            }

            if (Object.keys(lrcFiles).length === 0) {
                addLog('è¯·å…ˆä¸Šä¼  LRC æ–‡ä»¶', 'error');
                return;
            }

            // æ¸…ç©ºç°æœ‰è¡¨æ ¼
            const tbody = document.getElementById('songsTableBody');
            tbody.innerHTML = '';
            songRows = [];

            // è§£ææ­Œå•ï¼ˆæ¯è¡Œä¸€é¦–æ­Œï¼‰
            const playlist = playlistText.split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0);

            if (playlist.length === 0) {
                addLog('æ­Œå•ä¸­æ²¡æœ‰æœ‰æ•ˆçš„æ­Œæ›²åç§°', 'error');
                return;
            }

            let matchedCount = 0;
            let unmatchedSongs = [];

            // æŒ‰ç…§æ­Œå•é¡ºåºå¡«å……
            for (const songName of playlist) {
                // æŸ¥æ‰¾åŒ¹é…çš„LRCæ–‡ä»¶
                const matchedFiles = [];
                for (const fileName in lrcFiles) {
                    if (fuzzyMatch(songName, fileName)) {
                        matchedFiles.push(fileName);
                    }
                }

                if (matchedFiles.length > 0) {
                    // ä½¿ç”¨ç¬¬ä¸€ä¸ªåŒ¹é…çš„æ–‡ä»¶ - åˆ†é’Ÿå’Œç§’ç•™ç©ºï¼Œä¸é¢„å¡«0
                    addSongRow(songName, '', '', 10);
                    matchedCount++;
                } else {
                    unmatchedSongs.push(songName);
                }
            }

            // è®°å½•å¡«å……ç»“æœ
            addLog(`å·²æŒ‰æ­Œå•é¡ºåºå¡«å…… ${matchedCount} é¦–æ­Œæ›²`, 'success');
            
            if (unmatchedSongs.length > 0) {
                addLog(`ä»¥ä¸‹ ${unmatchedSongs.length} é¦–æ­Œæ›²æœªæ‰¾åˆ°åŒ¹é…çš„LRCæ–‡ä»¶ï¼š${unmatchedSongs.join(', ')}`, 'warning');
            }
            
            // æ›´æ–°é¢„è§ˆ
            updatePreview();
        }

        // æ›´æ–°è¡¨æ ¼åºå·
        function updateIndexes() {
            const rows = document.querySelectorAll('#songsTableBody tr');
            rows.forEach((row, index) => {
                const indexCell = row.querySelector('.index-cell');
                if (indexCell) indexCell.textContent = index + 1;
            });
        }

        // æ—¥å¿—
        function addLog(message, type='info') {
            const logContainer = document.getElementById('logContainer');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // æ›´æ–°è¿›åº¦æ¡ï¼ˆpercent 0-100ï¼‰
        function updateProgress(percent) {
            const bar = document.getElementById('progressBar');
            bar.style.width = Math.min(Math.max(percent, 0), 100) + '%';
        }

        // ---------- å¤„ç†ä¸Šä¼ æ–‡ä»¶ ----------
        async function handleFileUpload(event) {
            const files = Array.from(event.target.files || []);
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = '';
            lrcFiles = {}; // é‡ç½®
            addLog(`å·²é€‰æ‹© ${files.length} ä¸ªæ–‡ä»¶ï¼Œå¼€å§‹è¯»å–...`, 'info');
            updateProgress(0);

            if (files.length === 0) {
                addLog('æœªé€‰æ‹©ä»»ä½•æ–‡ä»¶', 'error');
                return;
            }

            let totalOuter = files.length;
            let outerIndex = 0;

            for (const file of files) {
                outerIndex++;
                const fileExt = (file.name.split('.').pop() || '').toLowerCase();

                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.innerHTML = `
                    <div class="file-name">${file.name}</div>
                    <div class="file-status status-ready">å¤„ç†ä¸­...</div>
                `;
                fileList.appendChild(fileItem);

                try {
                    if (fileExt === 'zip') {
                        // ä½¿ç”¨ JSZip è§£å‹
                        let zip = await JSZip.loadAsync(file);
                        const zipFiles = [];
                        zip.forEach((relativePath, zipEntry) => {
                            if (!zipEntry.dir && relativePath.toLowerCase().endsWith('.lrc')) {
                                zipFiles.push({relativePath, zipEntry});
                            }
                        });

                        addLog(`åœ¨ZIPä¸­æ‰¾åˆ° ${zipFiles.length} ä¸ª LRCï¼š${file.name}`, 'info');

                        if (zipFiles.length === 0) {
                            fileItem.querySelector('.file-status').className = 'file-status status-error';
                            fileItem.querySelector('.file-status').textContent = 'æ—  LRC æ–‡ä»¶';
                            updateProgress(outerIndex / totalOuter * 100);
                            continue;
                        }

                        for (let i = 0; i < zipFiles.length; i++) {
                            const {relativePath, zipEntry} = zipFiles[i];
                            try {
                                const lrcContent = await zipEntry.async('text');
                                const fileName = relativePath.split('/').pop().replace(/\.lrc$/i, '');
                                lrcFiles[fileName] = { name: fileName, content: lrcContent, source: file.name };
                            } catch (e) {
                                addLog(`ZIP å†…éƒ¨è¯»å–å¤±è´¥: ${relativePath} - ${e.message}`, 'error');
                            }
                            // å…è®¸ UI åˆ·æ–°ï¼Œé˜²æ­¢é˜»å¡ï¼ˆå¤§é‡æ–‡ä»¶æ—¶å¾ˆé‡è¦ï¼‰
                            await new Promise(r => setTimeout(r, 0));
                            updateProgress(((outerIndex - 1) + (i + 1) / Math.max(zipFiles.length,1)) / totalOuter * 100);
                        }

                        fileItem.querySelector('.file-status').textContent = `å·²æå– ${zipFiles.length} ä¸ªæ–‡ä»¶`;
                        addLog(`æˆåŠŸä» ZIP æå– ${zipFiles.length} ä¸ª LRCï¼š${file.name}`, 'success');

                    } else if (fileExt === 'lrc') {
                        // ç›´æ¥è¯»å–æ–‡æœ¬ï¼ˆç°ä»£æµè§ˆå™¨æ”¯æŒ file.text()ï¼‰
                        const text = await file.text();
                        const fileName = file.name.replace(/\.lrc$/i, '');
                        lrcFiles[fileName] = { name: fileName, content: text, source: file.name };
                        fileItem.querySelector('.file-status').textContent = 'å·²åŠ è½½';
                        addLog(`æˆåŠŸè¯»å– LRC: ${file.name}`, 'success');
                        updateProgress(outerIndex / totalOuter * 100);
                    } else {
                        fileItem.querySelector('.file-status').className = 'file-status status-error';
                        fileItem.querySelector('.file-status').textContent = 'ä¸æ”¯æŒçš„ç±»å‹';
                        addLog(`è·³è¿‡ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: ${file.name}`, 'error');
                        updateProgress(outerIndex / totalOuter * 100);
                    }
                } catch (err) {
                    addLog(`å¤„ç†æ–‡ä»¶å¤±è´¥: ${file.name} - ${err.message}`, 'error');
                    fileItem.querySelector('.file-status').className = 'file-status status-error';
                    fileItem.querySelector('.file-status').textContent = 'å¤„ç†å¤±è´¥';
                }
            }

            addLog(`æ–‡ä»¶è¯»å–å®Œæˆï¼Œå…± ${Object.keys(lrcFiles).length} é¦– LRC è¢«åŠ è½½`, 'success');
            updateProgress(100);

            // å°†è”æƒ³å€™é€‰æ›´æ–°å¹¶ä¿æ´»ï¼ˆä½†ä¸è‡ªåŠ¨å¡«å……ï¼‰
            enableAutoCompleteForSongs();
            
            // æ›´æ–°é¢„è§ˆ
            updatePreview();
        }

        // ---------- åŠ¨æ€è¡¨æ ¼ï¼ˆå¢åˆ æ”¹ï¼‰ ----------
        function addSongRow(songName = '', minutes = '', seconds = '', duration = 10) {
            const tbody = document.getElementById('songsTableBody');
            const rowId = 'row_' + Date.now() + '_' + Math.random().toString(36).substr(2,9);

            const row = document.createElement('tr');
            row.id = rowId;
            row.innerHTML = `
                <td class="index-column index-cell">${tbody.children.length + 1}</td>
                <td class="song-name-column">
                    <input type="text" class="song-input" value="${escapeHtml(songName)}" placeholder="è¾“å…¥æ­Œæ›²åç§°">
                </td>
                <td class="start-time-column">
                    <div class="time-input-group">
                        <input type="number" class="minute-input time-input" value="${minutes}" placeholder="åˆ†" min="0">
                        <span class="time-separator">:</span>
                        <input type="number" class="second-input time-input" value="${seconds}" placeholder="ç§’" min="0" max="59">
                    </div>
                </td>
                <td class="duration-column"><input type="number" class="duration-input" value="${duration}" step="0.1" min="1"></td>
                <td class="action-column">
                    <div class="action-buttons">
                        <button class="btn-primary action-btn" onclick="insertRowAt('${rowId}')">æ’å…¥</button>
                        <button class="btn-danger action-btn" type="button">åˆ é™¤</button>
                    </div>
                </td>
            `;
            tbody.appendChild(row);

            // ä¿å­˜åˆ° songRows
            songRows.push({
                id: rowId,
                songName: songName,
                minutes: minutes,
                seconds: seconds,
                duration: duration
            });

            // ç»‘å®šäº‹ä»¶ï¼šè¾“å…¥æ”¹å˜ã€åˆ é™¤æŒ‰é’®ã€è‡ªåŠ¨è¡¥å…¨
            const songInput = row.querySelector('.song-input');
            const minuteInput = row.querySelector('.minute-input');
            const secondInput = row.querySelector('.second-input');
            const durationInput = row.querySelector('.duration-input');
            const delBtn = row.querySelector('.action-btn.btn-danger');

            songInput.addEventListener('input', () => {
                updateSongRow(rowId);
                schedulePreviewUpdate();
            });
            minuteInput.addEventListener('input', () => {
                updateSongRow(rowId);
                schedulePreviewUpdate();
            });
            secondInput.addEventListener('input', () => {
                updateSongRow(rowId);
                schedulePreviewUpdate();
            });
            durationInput.addEventListener('input', () => {
                updateSongRow(rowId);
                schedulePreviewUpdate();
            });
            delBtn.addEventListener('click', () => deleteSongRow(rowId));
            
            // å³é”®èœå•äº‹ä»¶
            row.addEventListener('contextmenu', (e) => showContextMenu(e, rowId));

            // ç»‘å®šè‡ªåŠ¨è¡¥å…¨ï¼ˆå€™é€‰åŠ¨æ€æ¥è‡ª lrcFiles çš„ keysï¼‰
            setupAutoComplete(songInput, () => Object.keys(lrcFiles), rowId);

            updateIndexes();
        }

        function deleteSongRow(rowId) {
            const row = document.getElementById(rowId);
            if (!row) return;
            // æ¸…ç†è‡ªåŠ¨è¡¥å…¨ wrapperï¼ˆå¦‚æœæœ‰ï¼‰
            const songInput = row.querySelector('.song-input');
            if (songInput && songInput._autocompleteWrapper) {
                try { songInput._autocompleteWrapper.remove(); } catch(e) {}
            }

            row.remove();
            const idx = songRows.findIndex(r => r.id === rowId);
            if (idx !== -1) songRows.splice(idx, 1);
            addLog('å·²åˆ é™¤æ­Œæ›²è¡Œ', 'info');
            updateIndexes();
            schedulePreviewUpdate();
        }

        function updateSongRow(rowId) {
            const row = document.getElementById(rowId);
            if (!row) return;
            const inputs = row.getElementsByTagName('input');
            const songName = inputs[0].value;
            const minutes = inputs[1].value; // ç›´æ¥ä¿å­˜å­—ç¬¦ä¸²ï¼Œä¸è½¬æ¢ä¸ºæ•°å­—
            const seconds = inputs[2].value; // ç›´æ¥ä¿å­˜å­—ç¬¦ä¸²ï¼Œä¸è½¬æ¢ä¸ºæ•°å­—
            const duration = parseFloat(inputs[3].value) || 10;

            const idx = songRows.findIndex(r => r.id === rowId);
            if (idx !== -1) {
                songRows[idx] = { 
                    id: rowId, 
                    songName: songName, 
                    minutes: minutes, 
                    seconds: seconds, 
                    duration: duration 
                };
            }
        }

        function applyBatchSettings() {
            const batchMinutes = document.getElementById('batchMinutes').value;
            const batchSeconds = document.getElementById('batchSeconds').value;
            const batchDuration = document.getElementById('batchDuration').value;
            
            let minutes = batchMinutes !== '' ? batchMinutes : null;
            let seconds = batchSeconds !== '' ? batchSeconds : null;
            let duration = batchDuration ? parseFloat(batchDuration) : null;
            
            if (minutes === null && seconds === null && duration === null) { 
                addLog('è¯·è¾“å…¥è¦æ‰¹é‡è®¾ç½®çš„å€¼', 'error'); 
                return; 
            }

            let updatedCount = 0;
            for (let song of songRows) {
                const row = document.getElementById(song.id);
                if (!row) continue;
                const inputs = row.getElementsByTagName('input');
                if (minutes !== null) inputs[1].value = minutes;
                if (seconds !== null) inputs[2].value = seconds;
                if (duration !== null) inputs[3].value = duration;
                updateSongRow(song.id);
                updatedCount++;
            }
            addLog(`å·²æ‰¹é‡æ›´æ–° ${updatedCount} é¦–æ­Œæ›²çš„è®¾ç½®`, 'success');
            schedulePreviewUpdate();
        }

        // ---------- è‡ªåŠ¨å¡«å……ï¼ˆæ ¹æ® lrcFiles çš„æ–‡ä»¶åå¡«å…¥ï¼‰ ----------
        function autoFillSongs() {
            const tbody = document.getElementById('songsTableBody');
            tbody.innerHTML = '';
            songRows = [];
            const keys = Object.keys(lrcFiles);
            if (keys.length === 0) { addLog('è¯·å…ˆä¸Šä¼  LRC æ–‡ä»¶', 'error'); return; }
            for (const name of keys) addSongRow(name, '', '', 10);
            addLog(`å·²æŒ‰æ–‡ä»¶åå¡«å…… ${keys.length} é¦–æ­Œæ›²`, 'success');
            schedulePreviewUpdate();
        }

        // ---------- æ¨¡ç³ŠåŒ¹é…ï¼ˆç”¨äºå¤„ç†æ—¶åŒ¹é…æ–‡ä»¶åï¼‰ ----------
        function fuzzyMatch(pattern, string) {
            if (!pattern) return true;
            const normalizedPattern = pattern.toLowerCase().replace(/\s/g, '');
            const normalizedString = string.toLowerCase().replace(/\s/g, '');
            for (let char of normalizedPattern) {
                if (!normalizedString.includes(char)) return false;
            }
            return true;
        }

        // ---------- æå–æ­Œè¯ï¼ˆæ ¹æ®æ—¶é—´æˆ³ï¼‰ ----------
        function extractLyrics(lrcContent, songName, startTime, duration = 10) {
            try {
                const lines = lrcContent.split(/\r?\n/);
                const extractedLyrics = [];
                const endTime = startTime + duration;

                for (let line of lines) {
                    if (!line) continue;
                    // è¡Œå¯èƒ½åŒ…å«å¤šä¸ªæ—¶é—´æ ‡ç­¾ï¼Œä¾‹å¦‚ [01:02.50][00:30.00]æ­Œè¯
                    const timeTags = [...line.matchAll(/\[(\d{1,2}):(\d{1,2})(?:\.(\d{1,3}))?\]/g)];
                    const text = line.replace(/\[(?:\d{1,2}:\d{1,2}(?:\.\d{1,3})?)\]/g, '').trim();
                    if (!timeTags.length || !text) continue;
                    for (const tag of timeTags) {
                        try {
                            const minutes = parseInt(tag[1], 10);
                            const seconds = parseInt(tag[2], 10);
                            const msec = tag[3] ? parseInt(tag[3].padEnd(3,'0'), 10) : 0;
                            const totalSeconds = minutes * 60 + seconds + (msec / 1000);
                            if (totalSeconds >= startTime && totalSeconds <= endTime) {
                                extractedLyrics.push(text);
                                break; // è‹¥æ­¤è¡Œä»»ä¸€æ—¶é—´æˆ³æ»¡è¶³åˆ™æ·»åŠ ä¸€æ¬¡
                            }
                        } catch (e) { continue; }
                    }
                }

                return {
                    success: true,
                    lyrics: extractedLyrics,
                    message: extractedLyrics.length > 0 ? `æå–æˆåŠŸ: ${songName} (${startTime}-${endTime}ç§’)` : `æ²¡æœ‰æ‰¾åˆ°æ­Œè¯: ${songName} (${startTime}-${endTime}ç§’)`
                };
            } catch (error) {
                return { success:false, lyrics:[], message:`å¤„ç†å¤±è´¥ (${songName}): ${error.message}` };
            }
        }

        // ---------- å¤„ç†å¹¶å¯¼å‡º Word ----------
        function processSongs() {
            if (Object.keys(lrcFiles).length === 0) { addLog('è¯·å…ˆä¸Šä¼  LRC æ–‡ä»¶', 'error'); return; }
            if (songRows.length === 0) { addLog('è¯·å…ˆæ·»åŠ æ­Œæ›²ä¿¡æ¯', 'error'); return; }

            addLog('å¼€å§‹å¤„ç†æ­Œæ›²...', 'info');
            updateProgress(0);

            let docContent = `<!DOCTYPE html><html><head><meta charset="utf-8"><title>æ­Œè¯æå–</title>
                <style>body{font-family:Arial, sans-serif;margin:20px;} h1{text-align:center;color:#2c3e50;} h2{color:#3498db;padding-bottom:5px;margin-top:25px;} p{margin:10px 0;}</style>
                </head><body><h1>æ­Œè¯æå–</h1>`;

            let processedCount = 0;
            const validRows = songRows.filter(s => s.songName && s.songName.trim());
            const totalSongs = validRows.length;
            if (totalSongs === 0) { addLog('æ²¡æœ‰æœ‰æ•ˆçš„æ­Œæ›²ä¿¡æ¯å¯å¤„ç†', 'error'); return; }

            for (let i = 0; i < songRows.length; i++) {
                const song = songRows[i];
                if (!song.songName || !song.songName.trim()) continue;
                
                // å¤„ç†ç©ºå€¼æƒ…å†µï¼Œç©ºå­—ç¬¦ä¸²è§†ä¸º0
                const minutes = song.minutes === '' ? 0 : parseInt(song.minutes) || 0;
                const seconds = song.seconds === '' ? 0 : parseInt(song.seconds) || 0;
                const startTime = minutes * 60 + seconds;
                
                addLog(`å¤„ç†æ­Œæ›² ${i+1}/${totalSongs}: ${song.songName} (ä» ${minutes}:${seconds} å¼€å§‹, æŒç»­ ${song.duration} ç§’)`, 'info');

                // æ‰¾åˆ°åŒ¹é…çš„æ–‡ä»¶åï¼ˆfuzzyï¼‰
                const matchedFiles = [];
                for (const fileName in lrcFiles) {
                    if (fuzzyMatch(song.songName, fileName)) matchedFiles.push(fileName);
                }

                if (matchedFiles.length === 0) {
                    addLog(`æœªæ‰¾åˆ°åŒ¹é…çš„æ­Œè¯æ–‡ä»¶: ${song.songName}`, 'error');
                    continue;
                }
                if (matchedFiles.length > 1) addLog(`æ‰¾åˆ°å¤šä¸ªåŒ¹é…æ–‡ä»¶ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ª: ${matchedFiles.join(', ')}`, 'info');

                const matchedFile = lrcFiles[matchedFiles[0]];
                const result = extractLyrics(matchedFile.content, song.songName, startTime, song.duration);
                if (result.success && result.lyrics.length > 0) {
                    docContent += `<h2>${escapeHtml(song.songName)}</h2>`;
                    for (const lyric of result.lyrics) docContent += `<p>${escapeHtml(lyric)}</p>`;
                    processedCount++;
                }
                addLog(result.message, (result.success && result.lyrics.length > 0) ? 'success' : 'error');
                updateProgress(Math.round((i+1) / totalSongs * 100));
            }

            docContent += '</body></html>';
            if (processedCount > 0) {
                const blob = new Blob([docContent], { type: 'application/msword' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'extracted_lyrics.doc';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                addLog(`å¤„ç†å®Œæˆï¼æˆåŠŸæå– ${processedCount} é¦–æ­Œæ›²çš„æ­Œè¯ï¼Œæ–‡ä»¶å·²ä¸‹è½½`, 'success');
            } else {
                addLog('æ²¡æœ‰æˆåŠŸæå–ä»»ä½•æ­Œè¯', 'error');
            }
            updateProgress(100);
        }

        // ---------- æ¸…ç©º ----------
        function clearAll() {
            document.getElementById('lrcFiles').value = '';
            document.getElementById('fileList').innerHTML = '';
            document.getElementById('songsTableBody').innerHTML = '';
            document.getElementById('logContainer').innerHTML = '<div class="log-entry log-info">å·²æ¸…ç©ºæ‰€æœ‰æ•°æ®ï¼Œå¯ä»¥é‡æ–°å¼€å§‹ã€‚</div>';
            document.getElementById('batchMinutes').value = '';
            document.getElementById('batchSeconds').value = '';
            document.getElementById('batchDuration').value = '10';
            document.getElementById('playlistInput').value = '';
            document.getElementById('searchInput').value = '';
            document.getElementById('searchResultsCount').textContent = '';
            updateProgress(0);
            lrcFiles = {};
            songRows = [];
            // ç§»é™¤é—ç•™è‡ªåŠ¨è¡¥å…¨ wrapperï¼ˆè‹¥æœ‰ï¼‰
            document.querySelectorAll('.autocomplete-list').forEach(e => e.remove());
            for (let i = 0; i < 3; i++) addSongRow();
            showPreviewEmpty();
            
            // æ¸…é™¤ä¿å­˜çš„è¿›åº¦
            localStorage.removeItem('lyricExtractorProgress');
            addLog('å·²æ¸…ç©ºæ‰€æœ‰æ•°æ®å¹¶åˆ é™¤ä¿å­˜çš„è¿›åº¦', 'info');
        }

        // ---------- è‡ªåŠ¨è¡¥å…¨å®ç° ----------
        // getData å¯ä»¥æ˜¯å‡½æ•°ï¼ˆè¿”å›æ•°ç»„ï¼‰æˆ–æ•°ç»„æœ¬èº«ï¼›rowId ç”¨äºåœ¨é€‰æ‹©åè°ƒç”¨ updateSongRow
        function setupAutoComplete(input, getData, rowId) {
            // ç§»é™¤å·²æœ‰ wrapperï¼ˆé˜²æ­¢é‡å¤ç»‘å®šï¼‰
            if (input._autocompleteWrapper) {
                try { input._autocompleteWrapper.remove(); } catch(e) {}
                input._autocompleteWrapper = null;
            }

            const wrapper = document.createElement('div');
            wrapper.className = 'autocomplete-list';
            wrapper.style.display = 'none';
            document.body.appendChild(wrapper);
            input._autocompleteWrapper = wrapper;

            let currentFocus = -1;

            function closeWrapper() {
                wrapper.style.display = 'none';
                wrapper.innerHTML = '';
                currentFocus = -1;
            }

            input.addEventListener('input', function() {
                const val = this.value.trim().toLowerCase();
                wrapper.innerHTML = '';
                currentFocus = -1;
                if (!val) { closeWrapper(); return; }

                const candidates = (typeof getData === 'function') ? getData() : (Array.isArray(getData) ? getData : []);
                if (!candidates || candidates.length === 0) { closeWrapper(); return; }

                const matches = candidates.filter(item => item.toLowerCase().includes(val));
                if (!matches || matches.length === 0) { closeWrapper(); return; }

                matches.slice(0, AUTOCOMPLETE_MAX).forEach(match => {
                    const div = document.createElement('div');
                    div.className = 'autocomplete-item';
                    div.textContent = match;
                    // mousedown ä¿è¯åœ¨ input blur å‰å¯ä»¥æ•è·ï¼ˆclick äº‹ä»¶å¯èƒ½æ™šäº blurï¼‰
                    div.addEventListener('mousedown', function(e) {
                        e.preventDefault();
                        input.value = match;
                        updateSongRow(rowId);
                        closeWrapper();
                        schedulePreviewUpdate();
                    });
                    wrapper.appendChild(div);
                });

                // å®šä½åˆ°è¾“å…¥æ¡†ä¸‹æ–¹
                const rect = input.getBoundingClientRect();
                wrapper.style.left = rect.left + window.scrollX + 'px';
                wrapper.style.top = rect.bottom + window.scrollY + 'px';
                wrapper.style.width = rect.width + 'px';
                wrapper.style.display = 'block';
            });

            input.addEventListener('keydown', function(e) {
                const items = wrapper.querySelectorAll('.autocomplete-item');
                if (!items || items.length === 0) {
                    if (e.key === 'Enter') {
                        // è‹¥æ— å€™é€‰ï¼Œåˆ™ä¿æŒç°çŠ¶
                    }
                    return;
                }
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    currentFocus++;
                    addActive(items);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    currentFocus--;
                    addActive(items);
                } else if (e.key === 'Enter') {
                    if (currentFocus > -1 && items[currentFocus]) {
                        e.preventDefault();
                        items[currentFocus].dispatchEvent(new MouseEvent('mousedown'));
                    } else if (items.length === 1) {
                        e.preventDefault();
                        items[0].dispatchEvent(new MouseEvent('mousedown'));
                    }
                } else if (e.key === 'Escape') {
                    closeWrapper();
                }
            });

            function addActive(items) {
                if (!items) return;
                items.forEach(it => it.classList.remove('active'));
                if (currentFocus >= items.length) currentFocus = 0;
                if (currentFocus < 0) currentFocus = items.length - 1;
                items[currentFocus].classList.add('active');
                items[currentFocus].scrollIntoView({ block: 'nearest' });
            }

            // ç‚¹å‡»é¡µé¢å…¶ä»–åœ°æ–¹æ—¶è‡ªåŠ¨å…³é—­ï¼ˆä½†å…è®¸ç‚¹å‡»å»ºè®®é¡¹ï¼‰
            document.addEventListener('click', function(e) {
                if (e.target !== input && e.target.parentNode !== wrapper) {
                    closeWrapper();
                }
            });
        }

        // ç»™æ‰€æœ‰ç°æœ‰ song-input å¯ç”¨è”æƒ³ï¼ˆidempotentï¼‰
        function enableAutoCompleteForSongs() {
            const inputs = document.querySelectorAll('.song-input');
            inputs.forEach(input => {
                // rowId
                const row = input.closest('tr');
                const rowId = row ? row.id : null;
                if (!input._autocompleteWrapper) setupAutoComplete(input, () => Object.keys(lrcFiles), rowId);
            });
        }

        // ---------- å°å·¥å…· ----------
        function escapeHtml(str) {
            if (!str && str !== 0) return '';
            return String(str).replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s]));
        }

    </script>
</body>
</html>