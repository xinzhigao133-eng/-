<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ğŸµ æ­Œè¯æå–å·¥å…·ï¼ˆå«æ­Œå•é¡ºåºå¡«å……ï¼‰</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* --- åŸæœ‰æ ·å¼ï¼ˆä¿ç•™å¹¶å¾®è°ƒï¼‰ --- */
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Noto Sans SC', Arial;
            line-height: 1.6; color: #333;
            background: linear-gradient(135deg,#6a11cb 0%,#2575fc 100%); min-height:100vh; padding:15px;
        }
        .container { max-width:100%; margin:0 auto; background:#fff; border-radius:15px; box-shadow:0 10px 30px rgba(0,0,0,0.2); overflow:hidden; }
        header { background:linear-gradient(135deg,#2c3e50 0%,#3498db 100%); color:#fff; padding:20px 15px; text-align:center; }
        header h1 { font-size:1.8em; margin-bottom:8px; }
        header p { opacity:0.95; }
        .main-content { display:flex; flex-direction:column; }
        .panel { padding:15px; }
        .left-panel { border-bottom:2px solid #f0f0f0; }
        .right-panel { background:#f8f9fa; flex:1; display:flex; flex-direction:column; }
        .section-title { font-size:1.3em; margin-bottom:15px; color:#2c3e50; border-bottom:2px solid #3498db; padding-bottom:10px; }
        .file-input-container { margin-bottom:20px; }
        .file-input-label { display:block; margin-bottom:8px; font-weight:600; color:#2c3e50; }
        .file-input { width:100%; padding:12px; border:2px dashed #3498db; border-radius:8px; background:#f8f9fa; font-size:16px; margin-bottom:10px; }
        .table-container { border:1px solid #ddd; border-radius:8px; overflow:auto; margin-bottom:20px; max-height:400px; }
        table { width:100%; border-collapse:collapse; min-width:600px; }
        th { background:#34495e; color:white; padding:12px 8px; text-align:left; position:sticky; top:0; font-size:14px; }
        td { padding:10px 8px; border-bottom:1px solid #eee; font-size:14px; vertical-align:middle; }
        .index-column { width:5%; min-width:40px; text-align:center; }
        .song-name-column { width:45%; min-width:150px; }
        .time-column { width:20%; min-width:100px; }
        .action-column { width:10%; min-width:80px; }
        input { width:100%; padding:8px; border:1px solid #ddd; border-radius:4px; font-size:14px; }
        input:focus { outline:none; border-color:#3498db; box-shadow:0 0 5px rgba(52,152,219,0.3); }
        .button-group { display:flex; gap:10px; margin-bottom:20px; flex-wrap:wrap; }
        button { padding:12px 16px; border:none; border-radius:6px; cursor:pointer; font-size:14px; font-weight:600; transition:all 0.3s; flex:1; min-width:120px; }
        .btn-primary { background:#3498db; color:#fff; }
        .btn-success { background:#27ae60; color:#fff; }
        .btn-danger { background:#e74c3c; color:#fff; }
        .btn-warning { background:#f39c12; color:#fff; }
        .log-container { flex:1; background:white; border:1px solid #ddd; border-radius:8px; padding:15px; overflow-y:auto; font-family:'Courier New', monospace; font-size:13px; line-height:1.4; min-height:200px; max-height:300px; }
        .log-entry { margin-bottom:8px; padding:5px; border-radius:3px; }
        .log-success { background:#d4edda; color:#155724; border-left:3px solid #28a745; }
        .log-error { background:#f8d7da; color:#721c24; border-left:3px solid #dc3545; }
        .log-info { background:#d1ecf1; color:#0c5460; border-left:3px solid #17a2b8; }
        .log-warning { background:#fff3cd; color:#856404; border-left:3px solid #ffc107; }
        .instructions { background:#fff3cd; border:1px solid #ffeaa7; border-radius:8px; padding:15px; margin-top:20px; font-size:14px; }
        .file-list { margin-top:15px; }
        .file-item { display:flex; justify-content:space-between; align-items:center; padding:8px; background:#f8f9fa; border-radius:4px; margin-bottom:5px; }
        .file-name { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
        .file-status { font-size:12px; padding:2px 6px; border-radius:3px; margin-left:10px; }
        .status-ready { background:#d4edda; color:#155724; }
        .status-error { background:#f8d7da; color:#721c24; }
        .action-buttons { display:flex; gap:5px; }
        .action-btn { padding:4px 8px; font-size:12px; min-width:auto; flex:none; }
        .progress-bar { width:100%; height:10px; background:#f0f0f0; border-radius:5px; margin:10px 0; overflow:hidden; }
        .progress { height:100%; background:#3498db; width:0%; transition:width 0.3s; }
        .batch-controls { display:flex; gap:10px; margin-bottom:15px; }
        .batch-input { flex:1; padding:8px; border:1px solid #ddd; border-radius:4px; }
        @media (min-width:768px) {
            .main-content { flex-direction:row; }
            .left-panel { flex:1; border-right:2px solid #f0f0f0; border-bottom:none; }
            .right-panel { width:350px; }
            .song-name-column { width:55%; }
            .time-column { width:15%; }
            .action-column { width:10%; }
        }

        /* --- è‡ªåŠ¨è¡¥å…¨æ ·å¼ --- */
        .autocomplete-list {
            position:absolute;
            border:1px solid #ccc;
            background:#fff;
            z-index:1200;
            max-height:220px;
            overflow-y:auto;
            font-size:14px;
            box-shadow:0 6px 18px rgba(0,0,0,0.12);
        }
        .autocomplete-item { padding:8px 10px; cursor:pointer; }
        .autocomplete-item:hover, .autocomplete-item.active { background:#f1f1f1; }
        
        /* --- æ­Œå•è¾“å…¥æ ·å¼ --- */
        .playlist-container { margin-bottom:20px; }
        .playlist-textarea {
            width:100%;
            padding:12px;
            border:2px dashed #f39c12;
            border-radius:8px;
            background:#fff9e6;
            font-size:14px;
            line-height:1.5;
            resize:vertical;
            min-height:120px;
        }
        .playlist-textarea:focus {
            outline:none;
            border-color:#e67e22;
            box-shadow:0 0 5px rgba(230,126,34,0.3);
        }
        .playlist-help {
            font-size:12px;
            color:#7f8c8d;
            margin-top:5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸµ æ­Œè¯æå–å·¥å…·</h1>
            <p>ä» LRC æ–‡ä»¶ä¸­æå–æŒ‡å®šæ—¶é—´æ®µçš„æ­Œè¯ï¼ˆæ”¯æŒ ZIP æ‰¹é‡ï¼‰</p>
        </header>

        <div class="main-content">
            <div class="panel left-panel">
                <h2 class="section-title">ä¸Šä¼ æ–‡ä»¶</h2>
                <div class="file-input-container">
                    <label class="file-input-label">é€‰æ‹© LRC æ–‡ä»¶æˆ– ZIP å‹ç¼©åŒ…ï¼š</label>
                    <input type="file" id="lrcFiles" accept=".lrc,.zip" multiple class="file-input">
                    <small>æ”¯æŒå•ä¸ª .lrcã€å¤šä¸ª .lrc æˆ–åŒ…å« LRC æ–‡ä»¶çš„ ZIP å‹ç¼©åŒ…</small>
                </div>

                <div id="fileList" class="file-list"></div>

                <h2 class="section-title" style="margin-top:20px;">æ­Œå•é¡ºåºè®¾ç½®</h2>
                
                <div class="playlist-container">
                    <textarea id="playlistInput" class="playlist-textarea" placeholder="è¯·åœ¨æ­¤è¾“å…¥æ‚¨çš„æ­Œå•é¡ºåºï¼Œæ¯è¡Œä¸€é¦–æ­Œåï¼ˆç¤ºä¾‹ï¼‰ï¼š
å¯Œå£«å±±ä¸‹
çˆ±æƒ…è½¬ç§»
çº¢ç«ç‘°
..."></textarea>
                    <div class="playlist-help">æ¯è¡Œè¾“å…¥ä¸€é¦–æ­Œæ›²åç§°ï¼Œç³»ç»Ÿå°†ä¸¥æ ¼æŒ‰ç…§æ­¤é¡ºåºå¡«å……æ­Œæ›²åˆ—è¡¨</div>
                </div>

                <h2 class="section-title">æ­Œæ›²åˆ—è¡¨ç¼–è¾‘</h2>

                <div class="batch-controls">
                    <input type="text" id="batchStartTime" class="batch-input" placeholder="æ‰¹é‡è®¾ç½®å¼€å§‹æ—¶é—´(ç§’)">
                    <input type="text" id="batchDuration" class="batch-input" placeholder="æ‰¹é‡è®¾ç½®æŒç»­æ—¶é—´(ç§’)">
                    <button class="btn-primary action-btn" onclick="applyBatchSettings()">åº”ç”¨</button>
                </div>

                <div class="table-container">
                    <table id="songsTable">
                        <thead>
                            <tr>
                                <th class="index-column">åºå·</th>
                                <th class="song-name-column">æ­Œæ›²åç§°</th>
                                <th class="time-column">å¼€å§‹æ—¶é—´(ç§’)</th>
                                <th class="time-column">æŒç»­æ—¶é—´(ç§’)</th>
                                <th class="action-column">æ“ä½œ</th>
                            </tr>
                        </thead>
                        <tbody id="songsTableBody"></tbody>
                    </table>
                </div>

                <div class="button-group">
                    <button class="btn-warning" onclick="fillSongsByPlaylist()">æŒ‰æ­Œå•é¡ºåºå¡«å……</button>
                    <button class="btn-primary" onclick="autoFillSongs()">æŒ‰æ–‡ä»¶åå¡«å……</button>
                    <button class="btn-warning" onclick="addSongRow()">æ·»åŠ æ­Œæ›²</button>
                    <button class="btn-success" onclick="processSongs()">å¼€å§‹å¤„ç†</button>
                    <button class="btn-danger" onclick="clearAll()">æ¸…ç©ºå…¨éƒ¨</button>
                </div>

                <div class="progress-bar">
                    <div class="progress" id="progressBar"></div>
                </div>

                <div class="instructions">
                    <h3>ä½¿ç”¨è¯´æ˜ï¼š</h3>
                    <p>1. ä¸Šä¼  LRC æ–‡ä»¶æˆ– ZIP å‹ç¼©åŒ…ï¼ˆæ”¯æŒå¤šæ–‡ä»¶ï¼‰</p>
                    <p>2. åœ¨"æ­Œå•é¡ºåºè®¾ç½®"ä¸­è¾“å…¥æ‚¨çš„æ­Œå•ï¼ˆæ¯è¡Œä¸€é¦–æ­Œåï¼‰</p>
                    <p>3. ç‚¹å‡»"æŒ‰æ­Œå•é¡ºåºå¡«å……"ä¸¥æ ¼æŒ‰ç…§æ­Œå•é¡ºåºå¡«å……æ­Œæ›²åˆ—è¡¨</p>
                    <p>4. åœ¨"æ­Œæ›²åç§°"è¾“å…¥æ—¶ä¼šæ ¹æ®ä¸Šä¼ çš„æ‰€æœ‰æ–‡ä»¶åè”æƒ³å»ºè®®ï¼ˆæ”¯æŒä¸Šä¸‹é”®å’Œå›è½¦ï¼‰</p>
                    <p>5. è®¾ç½®å¼€å§‹æ—¶é—´ä¸æŒç»­æ—¶é—´ï¼Œç‚¹å‡»"å¼€å§‹å¤„ç†"ç”Ÿæˆ Word æ–‡æ¡£</p>
                </div>
            </div>

            <div class="panel right-panel">
                <h2 class="section-title">å¤„ç†æ—¥å¿—</h2>
                <div class="log-container" id="logContainer">
                    <div class="log-entry log-info">æ¬¢è¿ä½¿ç”¨æ­Œè¯æå–å·¥å…·ï¼æ”¯æŒå‹ç¼©åŒ…ä¸Šä¼ å’Œæ­Œå•é¡ºåºå¡«å……ã€‚</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- å…¨å±€çŠ¶æ€ ---
        let lrcFiles = {};   // { fileNameNoExt: {name, content, source} }
        let songRows = [];   // [{id, songName, startTime, duration}]
        let AUTOCOMPLETE_MAX = 8;

        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('lrcFiles').addEventListener('change', handleFileUpload);
            // é»˜è®¤åˆ›å»º 3 è¡Œå¯ç¼–è¾‘è¡Œ
            for (let i = 0; i < 3; i++) addSongRow();
            updateIndexes();
        });

        // ---------- æ–°å¢åŠŸèƒ½ï¼šæŒ‰æ­Œå•é¡ºåºå¡«å…… ----------
        function fillSongsByPlaylist() {
            const playlistText = document.getElementById('playlistInput').value.trim();
            if (!playlistText) {
                addLog('è¯·åœ¨æ­Œå•è¾“å…¥æ¡†ä¸­è¾“å…¥æ­Œæ›²é¡ºåº', 'error');
                return;
            }

            if (Object.keys(lrcFiles).length === 0) {
                addLog('è¯·å…ˆä¸Šä¼  LRC æ–‡ä»¶', 'error');
                return;
            }

            // æ¸…ç©ºç°æœ‰è¡¨æ ¼
            const tbody = document.getElementById('songsTableBody');
            tbody.innerHTML = '';
            songRows = [];

            // è§£ææ­Œå•ï¼ˆæ¯è¡Œä¸€é¦–æ­Œï¼‰
            const playlist = playlistText.split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0);

            if (playlist.length === 0) {
                addLog('æ­Œå•ä¸­æ²¡æœ‰æœ‰æ•ˆçš„æ­Œæ›²åç§°', 'error');
                return;
            }

            let matchedCount = 0;
            let unmatchedSongs = [];

            // æŒ‰ç…§æ­Œå•é¡ºåºå¡«å……
            for (const songName of playlist) {
                // æŸ¥æ‰¾åŒ¹é…çš„LRCæ–‡ä»¶
                const matchedFiles = [];
                for (const fileName in lrcFiles) {
                    if (fuzzyMatch(songName, fileName)) {
                        matchedFiles.push(fileName);
                    }
                }

                if (matchedFiles.length > 0) {
                    // ä½¿ç”¨ç¬¬ä¸€ä¸ªåŒ¹é…çš„æ–‡ä»¶
                    addSongRow(songName, '', 15);
                    matchedCount++;
                } else {
                    unmatchedSongs.push(songName);
                }
            }

            // è®°å½•å¡«å……ç»“æœ
            addLog(`å·²æŒ‰æ­Œå•é¡ºåºå¡«å…… ${matchedCount} é¦–æ­Œæ›²`, 'success');
            
            if (unmatchedSongs.length > 0) {
                addLog(`ä»¥ä¸‹ ${unmatchedSongs.length} é¦–æ­Œæ›²æœªæ‰¾åˆ°åŒ¹é…çš„LRCæ–‡ä»¶ï¼š${unmatchedSongs.join(', ')}`, 'warning');
            }
        }

        // æ›´æ–°è¡¨æ ¼åºå·
        function updateIndexes() {
            const rows = document.querySelectorAll('#songsTableBody tr');
            rows.forEach((row, index) => {
                const indexCell = row.querySelector('.index-cell');
                if (indexCell) indexCell.textContent = index + 1;
            });
        }

        // æ—¥å¿—
        function addLog(message, type='info') {
            const logContainer = document.getElementById('logContainer');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // æ›´æ–°è¿›åº¦æ¡ï¼ˆpercent 0-100ï¼‰
        function updateProgress(percent) {
            const bar = document.getElementById('progressBar');
            bar.style.width = Math.min(Math.max(percent, 0), 100) + '%';
        }

        // ---------- å¤„ç†ä¸Šä¼ æ–‡ä»¶ ----------
        async function handleFileUpload(event) {
            const files = Array.from(event.target.files || []);
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = '';
            lrcFiles = {}; // é‡ç½®
            addLog(`å·²é€‰æ‹© ${files.length} ä¸ªæ–‡ä»¶ï¼Œå¼€å§‹è¯»å–...`, 'info');
            updateProgress(0);

            if (files.length === 0) {
                addLog('æœªé€‰æ‹©ä»»ä½•æ–‡ä»¶', 'error');
                return;
            }

            let totalOuter = files.length;
            let outerIndex = 0;

            for (const file of files) {
                outerIndex++;
                const fileExt = (file.name.split('.').pop() || '').toLowerCase();

                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.innerHTML = `
                    <div class="file-name">${file.name}</div>
                    <div class="file-status status-ready">å¤„ç†ä¸­...</div>
                `;
                fileList.appendChild(fileItem);

                try {
                    if (fileExt === 'zip') {
                        // ä½¿ç”¨ JSZip è§£å‹
                        let zip = await JSZip.loadAsync(file);
                        const zipFiles = [];
                        zip.forEach((relativePath, zipEntry) => {
                            if (!zipEntry.dir && relativePath.toLowerCase().endsWith('.lrc')) {
                                zipFiles.push({relativePath, zipEntry});
                            }
                        });

                        addLog(`åœ¨ZIPä¸­æ‰¾åˆ° ${zipFiles.length} ä¸ª LRCï¼š${file.name}`, 'info');

                        if (zipFiles.length === 0) {
                            fileItem.querySelector('.file-status').className = 'file-status status-error';
                            fileItem.querySelector('.file-status').textContent = 'æ—  LRC æ–‡ä»¶';
                            updateProgress(outerIndex / totalOuter * 100);
                            continue;
                        }

                        for (let i = 0; i < zipFiles.length; i++) {
                            const {relativePath, zipEntry} = zipFiles[i];
                            try {
                                const lrcContent = await zipEntry.async('text');
                                const fileName = relativePath.split('/').pop().replace(/\.lrc$/i, '');
                                lrcFiles[fileName] = { name: fileName, content: lrcContent, source: file.name };
                            } catch (e) {
                                addLog(`ZIP å†…éƒ¨è¯»å–å¤±è´¥: ${relativePath} - ${e.message}`, 'error');
                            }
                            // å…è®¸ UI åˆ·æ–°ï¼Œé˜²æ­¢é˜»å¡ï¼ˆå¤§é‡æ–‡ä»¶æ—¶å¾ˆé‡è¦ï¼‰
                            await new Promise(r => setTimeout(r, 0));
                            updateProgress(((outerIndex - 1) + (i + 1) / Math.max(zipFiles.length,1)) / totalOuter * 100);
                        }

                        fileItem.querySelector('.file-status').textContent = `å·²æå– ${zipFiles.length} ä¸ªæ–‡ä»¶`;
                        addLog(`æˆåŠŸä» ZIP æå– ${zipFiles.length} ä¸ª LRCï¼š${file.name}`, 'success');

                    } else if (fileExt === 'lrc') {
                        // ç›´æ¥è¯»å–æ–‡æœ¬ï¼ˆç°ä»£æµè§ˆå™¨æ”¯æŒ file.text()ï¼‰
                        const text = await file.text();
                        const fileName = file.name.replace(/\.lrc$/i, '');
                        lrcFiles[fileName] = { name: fileName, content: text, source: file.name };
                        fileItem.querySelector('.file-status').textContent = 'å·²åŠ è½½';
                        addLog(`æˆåŠŸè¯»å– LRC: ${file.name}`, 'success');
                        updateProgress(outerIndex / totalOuter * 100);
                    } else {
                        fileItem.querySelector('.file-status').className = 'file-status status-error';
                        fileItem.querySelector('.file-status').textContent = 'ä¸æ”¯æŒçš„ç±»å‹';
                        addLog(`è·³è¿‡ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: ${file.name}`, 'error');
                        updateProgress(outerIndex / totalOuter * 100);
                    }
                } catch (err) {
                    addLog(`å¤„ç†æ–‡ä»¶å¤±è´¥: ${file.name} - ${err.message}`, 'error');
                    fileItem.querySelector('.file-status').className = 'file-status status-error';
                    fileItem.querySelector('.file-status').textContent = 'å¤„ç†å¤±è´¥';
                }
            }

            addLog(`æ–‡ä»¶è¯»å–å®Œæˆï¼Œå…± ${Object.keys(lrcFiles).length} é¦– LRC è¢«åŠ è½½`, 'success');
            updateProgress(100);

            // å°†è”æƒ³å€™é€‰æ›´æ–°å¹¶ä¿æ´»ï¼ˆä½†ä¸è‡ªåŠ¨å¡«å……ï¼‰
            enableAutoCompleteForSongs();
        }

        // ---------- åŠ¨æ€è¡¨æ ¼ï¼ˆå¢åˆ æ”¹ï¼‰ ----------
        function addSongRow(songName = '', startTime = '', duration = 15) {
            const tbody = document.getElementById('songsTableBody');
            const rowId = 'row_' + Date.now() + '_' + Math.random().toString(36).substr(2,9);

            const row = document.createElement('tr');
            row.id = rowId;
            row.innerHTML = `
                <td class="index-column index-cell">${tbody.children.length + 1}</td>
                <td class="song-name-column">
                    <input type="text" class="song-input" value="${escapeHtml(songName)}" placeholder="è¾“å…¥æ­Œæ›²åç§°">
                </td>
                <td class="time-column"><input type="number" class="start-input" value="${startTime === '' ? '' : startTime}" placeholder="0" step="0.1" min="0"></td>
                <td class="time-column"><input type="number" class="duration-input" value="${duration}" step="0.1" min="1"></td>
                <td class="action-column">
                    <div class="action-buttons">
                        <button class="btn-danger action-btn" type="button">åˆ é™¤</button>
                    </div>
                </td>
            `;
            tbody.appendChild(row);

            // ä¿å­˜åˆ° songRows
            songRows.push({
                id: rowId,
                songName: songName,
                startTime: startTime === '' ? 0 : parseFloat(startTime) || 0,
                duration: parseFloat(duration) || 15
            });

            // ç»‘å®šäº‹ä»¶ï¼šè¾“å…¥æ”¹å˜ã€åˆ é™¤æŒ‰é’®ã€è‡ªåŠ¨è¡¥å…¨
            const songInput = row.querySelector('.song-input');
            const startInput = row.querySelector('.start-input');
            const durationInput = row.querySelector('.duration-input');
            const delBtn = row.querySelector('.action-btn');

            songInput.addEventListener('input', () => updateSongRow(rowId));
            startInput.addEventListener('input', () => updateSongRow(rowId));
            durationInput.addEventListener('input', () => updateSongRow(rowId));
            delBtn.addEventListener('click', () => deleteSongRow(rowId));

            // ç»‘å®šè‡ªåŠ¨è¡¥å…¨ï¼ˆå€™é€‰åŠ¨æ€æ¥è‡ª lrcFiles çš„ keysï¼‰
            setupAutoComplete(songInput, () => Object.keys(lrcFiles), rowId);

            updateIndexes();
        }

        function deleteSongRow(rowId) {
            const row = document.getElementById(rowId);
            if (!row) return;
            // æ¸…ç†è‡ªåŠ¨è¡¥å…¨ wrapperï¼ˆå¦‚æœæœ‰ï¼‰
            const songInput = row.querySelector('.song-input');
            if (songInput && songInput._autocompleteWrapper) {
                try { songInput._autocompleteWrapper.remove(); } catch(e) {}
            }

            row.remove();
            const idx = songRows.findIndex(r => r.id === rowId);
            if (idx !== -1) songRows.splice(idx, 1);
            addLog('å·²åˆ é™¤æ­Œæ›²è¡Œ', 'info');
            updateIndexes();
        }

        function updateSongRow(rowId) {
            const row = document.getElementById(rowId);
            if (!row) return;
            const inputs = row.getElementsByTagName('input');
            const songName = inputs[0].value;
            const startTime = inputs[1].value === '' ? 0 : parseFloat(inputs[1].value) || 0;
            const duration = parseFloat(inputs[2].value) || 15;

            const idx = songRows.findIndex(r => r.id === rowId);
            if (idx !== -1) {
                songRows[idx] = { id: rowId, songName: songName, startTime: startTime, duration: duration };
            }
        }

        function applyBatchSettings() {
            const batchStartTime = document.getElementById('batchStartTime').value;
            const batchDuration = document.getElementById('batchDuration').value;
            let startTime = batchStartTime ? parseFloat(batchStartTime) : null;
            let duration = batchDuration ? parseFloat(batchDuration) : null;
            if (startTime === null && duration === null) { addLog('è¯·è¾“å…¥è¦æ‰¹é‡è®¾ç½®çš„å€¼', 'error'); return; }

            let updatedCount = 0;
            for (let song of songRows) {
                const row = document.getElementById(song.id);
                if (!row) continue;
                const inputs = row.getElementsByTagName('input');
                if (startTime !== null) inputs[1].value = startTime;
                if (duration !== null) inputs[2].value = duration;
                updateSongRow(song.id);
                updatedCount++;
            }
            addLog(`å·²æ‰¹é‡æ›´æ–° ${updatedCount} é¦–æ­Œæ›²çš„è®¾ç½®`, 'success');
        }

        // ---------- è‡ªåŠ¨å¡«å……ï¼ˆæ ¹æ® lrcFiles çš„æ–‡ä»¶åå¡«å…¥ï¼‰ ----------
        function autoFillSongs() {
            const tbody = document.getElementById('songsTableBody');
            tbody.innerHTML = '';
            songRows = [];
            const keys = Object.keys(lrcFiles);
            if (keys.length === 0) { addLog('è¯·å…ˆä¸Šä¼  LRC æ–‡ä»¶', 'error'); return; }
            for (const name of keys) addSongRow(name, '', 15);
            addLog(`å·²æŒ‰æ–‡ä»¶åå¡«å…… ${keys.length} é¦–æ­Œæ›²`, 'success');
        }

        // ---------- æ¨¡ç³ŠåŒ¹é…ï¼ˆç”¨äºå¤„ç†æ—¶åŒ¹é…æ–‡ä»¶åï¼‰ ----------
        function fuzzyMatch(pattern, string) {
            if (!pattern) return true;
            const normalizedPattern = pattern.toLowerCase().replace(/\s/g, '');
            const normalizedString = string.toLowerCase().replace(/\s/g, '');
            for (let char of normalizedPattern) {
                if (!normalizedString.includes(char)) return false;
            }
            return true;
        }

        // ---------- æå–æ­Œè¯ï¼ˆæ ¹æ®æ—¶é—´æˆ³ï¼‰ ----------
        function extractLyrics(lrcContent, songName, startTime, duration = 15) {
            try {
                const lines = lrcContent.split(/\r?\n/);
                const extractedLyrics = [];
                const endTime = startTime + duration;

                for (let line of lines) {
                    if (!line) continue;
                    // è¡Œå¯èƒ½åŒ…å«å¤šä¸ªæ—¶é—´æ ‡ç­¾ï¼Œä¾‹å¦‚ [01:02.50][00:30.00]æ­Œè¯
                    const timeTags = [...line.matchAll(/\[(\d{1,2}):(\d{1,2})(?:\.(\d{1,3}))?\]/g)];
                    const text = line.replace(/\[(?:\d{1,2}:\d{1,2}(?:\.\d{1,3})?)\]/g, '').trim();
                    if (!timeTags.length || !text) continue;
                    for (const tag of timeTags) {
                        try {
                            const minutes = parseInt(tag[1], 10);
                            const seconds = parseInt(tag[2], 10);
                            const msec = tag[3] ? parseInt(tag[3].padEnd(3,'0'), 10) : 0;
                            const totalSeconds = minutes * 60 + seconds + (msec / 1000);
                            if (totalSeconds >= startTime && totalSeconds <= endTime) {
                                extractedLyrics.push(text);
                                break; // è‹¥æ­¤è¡Œä»»ä¸€æ—¶é—´æˆ³æ»¡è¶³åˆ™æ·»åŠ ä¸€æ¬¡
                            }
                        } catch (e) { continue; }
                    }
                }

                return {
                    success: true,
                    lyrics: extractedLyrics,
                    message: extractedLyrics.length > 0 ? `æå–æˆåŠŸ: ${songName} (${startTime}-${endTime}ç§’)` : `æ²¡æœ‰æ‰¾åˆ°æ­Œè¯: ${songName} (${startTime}-${endTime}ç§’)`
                };
            } catch (error) {
                return { success:false, lyrics:[], message:`å¤„ç†å¤±è´¥ (${songName}): ${error.message}` };
            }
        }

        // ---------- å¤„ç†å¹¶å¯¼å‡º Word ----------
        function processSongs() {
            if (Object.keys(lrcFiles).length === 0) { addLog('è¯·å…ˆä¸Šä¼  LRC æ–‡ä»¶', 'error'); return; }
            if (songRows.length === 0) { addLog('è¯·å…ˆæ·»åŠ æ­Œæ›²ä¿¡æ¯', 'error'); return; }

            addLog('å¼€å§‹å¤„ç†æ­Œæ›²...', 'info');
            updateProgress(0);

            let docContent = `<!DOCTYPE html><html><head><meta charset="utf-8"><title>æ­Œè¯æå–</title>
                <style>body{font-family:Arial, sans-serif;margin:20px;} h1{text-align:center;color:#2c3e50;} h2{color:#3498db;padding-bottom:5px;margin-top:25px;} p{margin:10px 0;}</style>
                </head><body><h1>æ­Œè¯æå–</h1>`;

            let processedCount = 0;
            const validRows = songRows.filter(s => s.songName && s.songName.trim());
            const totalSongs = validRows.length;
            if (totalSongs === 0) { addLog('æ²¡æœ‰æœ‰æ•ˆçš„æ­Œæ›²ä¿¡æ¯å¯å¤„ç†', 'error'); return; }

            for (let i = 0; i < songRows.length; i++) {
                const song = songRows[i];
                if (!song.songName || !song.songName.trim()) continue;
                addLog(`å¤„ç†æ­Œæ›² ${i+1}/${totalSongs}: ${song.songName} (ä» ${song.startTime} ç§’å¼€å§‹, æŒç»­ ${song.duration} ç§’)`, 'info');

                // æ‰¾åˆ°åŒ¹é…çš„æ–‡ä»¶åï¼ˆfuzzyï¼‰
                const matchedFiles = [];
                for (const fileName in lrcFiles) {
                    if (fuzzyMatch(song.songName, fileName)) matchedFiles.push(fileName);
                }

                if (matchedFiles.length === 0) {
                    addLog(`æœªæ‰¾åˆ°åŒ¹é…çš„æ­Œè¯æ–‡ä»¶: ${song.songName}`, 'error');
                    continue;
                }
                if (matchedFiles.length > 1) addLog(`æ‰¾åˆ°å¤šä¸ªåŒ¹é…æ–‡ä»¶ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ª: ${matchedFiles.join(', ')}`, 'info');

                const matchedFile = lrcFiles[matchedFiles[0]];
                const result = extractLyrics(matchedFile.content, song.songName, song.startTime, song.duration);
                if (result.success && result.lyrics.length > 0) {
                    docContent += `<h2>${escapeHtml(song.songName)}</h2>`;
                    for (const lyric of result.lyrics) docContent += `<p>${escapeHtml(lyric)}</p>`;
                    processedCount++;
                }
                addLog(result.message, (result.success && result.lyrics.length > 0) ? 'success' : 'error');
                updateProgress(Math.round((i+1) / totalSongs * 100));
            }

            docContent += '</body></html>';
            if (processedCount > 0) {
                const blob = new Blob([docContent], { type: 'application/msword' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'extracted_lyrics.doc';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                addLog(`å¤„ç†å®Œæˆï¼æˆåŠŸæå– ${processedCount} é¦–æ­Œæ›²çš„æ­Œè¯ï¼Œæ–‡ä»¶å·²ä¸‹è½½`, 'success');
            } else {
                addLog('æ²¡æœ‰æˆåŠŸæå–ä»»ä½•æ­Œè¯', 'error');
            }
            updateProgress(100);
        }

        // ---------- æ¸…ç©º ----------
        function clearAll() {
            document.getElementById('lrcFiles').value = '';
            document.getElementById('fileList').innerHTML = '';
            document.getElementById('songsTableBody').innerHTML = '';
            document.getElementById('logContainer').innerHTML = '<div class="log-entry log-info">å·²æ¸…ç©ºæ‰€æœ‰æ•°æ®ï¼Œå¯ä»¥é‡æ–°å¼€å§‹ã€‚</div>';
            document.getElementById('batchStartTime').value = '';
            document.getElementById('batchDuration').value = '';
            document.getElementById('playlistInput').value = '';
            updateProgress(0);
            lrcFiles = {};
            songRows = [];
            // ç§»é™¤é—ç•™è‡ªåŠ¨è¡¥å…¨ wrapperï¼ˆè‹¥æœ‰ï¼‰
            document.querySelectorAll('.autocomplete-list').forEach(e => e.remove());
            for (let i = 0; i < 3; i++) addSongRow();
        }

        // ---------- è‡ªåŠ¨è¡¥å…¨å®ç° ----------
        // getData å¯ä»¥æ˜¯å‡½æ•°ï¼ˆè¿”å›æ•°ç»„ï¼‰æˆ–æ•°ç»„æœ¬èº«ï¼›rowId ç”¨äºåœ¨é€‰æ‹©åè°ƒç”¨ updateSongRow
        function setupAutoComplete(input, getData, rowId) {
            // ç§»é™¤å·²æœ‰ wrapperï¼ˆé˜²æ­¢é‡å¤ç»‘å®šï¼‰
            if (input._autocompleteWrapper) {
                try { input._autocompleteWrapper.remove(); } catch(e) {}
                input._autocompleteWrapper = null;
            }

            const wrapper = document.createElement('div');
            wrapper.className = 'autocomplete-list';
            wrapper.style.display = 'none';
            document.body.appendChild(wrapper);
            input._autocompleteWrapper = wrapper;

            let currentFocus = -1;

            function closeWrapper() {
                wrapper.style.display = 'none';
                wrapper.innerHTML = '';
                currentFocus = -1;
            }

            input.addEventListener('input', function() {
                const val = this.value.trim().toLowerCase();
                wrapper.innerHTML = '';
                currentFocus = -1;
                if (!val) { closeWrapper(); return; }

                const candidates = (typeof getData === 'function') ? getData() : (Array.isArray(getData) ? getData : []);
                if (!candidates || candidates.length === 0) { closeWrapper(); return; }

                const matches = candidates.filter(item => item.toLowerCase().includes(val));
                if (!matches || matches.length === 0) { closeWrapper(); return; }

                matches.slice(0, AUTOCOMPLETE_MAX).forEach(match => {
                    const div = document.createElement('div');
                    div.className = 'autocomplete-item';
                    div.textContent = match;
                    // mousedown ä¿è¯åœ¨ input blur å‰å¯ä»¥æ•è·ï¼ˆclick äº‹ä»¶å¯èƒ½æ™šäº blurï¼‰
                    div.addEventListener('mousedown', function(e) {
                        e.preventDefault();
                        input.value = match;
                        updateSongRow(rowId);
                        closeWrapper();
                    });
                    wrapper.appendChild(div);
                });

                // å®šä½åˆ°è¾“å…¥æ¡†ä¸‹æ–¹
                const rect = input.getBoundingClientRect();
                wrapper.style.left = rect.left + window.scrollX + 'px';
                wrapper.style.top = rect.bottom + window.scrollY + 'px';
                wrapper.style.width = rect.width + 'px';
                wrapper.style.display = 'block';
            });

            input.addEventListener('keydown', function(e) {
                const items = wrapper.querySelectorAll('.autocomplete-item');
                if (!items || items.length === 0) {
                    if (e.key === 'Enter') {
                        // è‹¥æ— å€™é€‰ï¼Œåˆ™ä¿æŒç°çŠ¶
                    }
                    return;
                }
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    currentFocus++;
                    addActive(items);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    currentFocus--;
                    addActive(items);
                } else if (e.key === 'Enter') {
                    if (currentFocus > -1 && items[currentFocus]) {
                        e.preventDefault();
                        items[currentFocus].dispatchEvent(new MouseEvent('mousedown'));
                    } else if (items.length === 1) {
                        e.preventDefault();
                        items[0].dispatchEvent(new MouseEvent('mousedown'));
                    }
                } else if (e.key === 'Escape') {
                    closeWrapper();
                }
            });

            function addActive(items) {
                if (!items) return;
                items.forEach(it => it.classList.remove('active'));
                if (currentFocus >= items.length) currentFocus = 0;
                if (currentFocus < 0) currentFocus = items.length - 1;
                items[currentFocus].classList.add('active');
                items[currentFocus].scrollIntoView({ block: 'nearest' });
            }

            // ç‚¹å‡»é¡µé¢å…¶ä»–åœ°æ–¹æ—¶è‡ªåŠ¨å…³é—­ï¼ˆä½†å…è®¸ç‚¹å‡»å»ºè®®é¡¹ï¼‰
            document.addEventListener('click', function(e) {
                if (e.target !== input && e.target.parentNode !== wrapper) {
                    closeWrapper();
                }
            });
        }

        // ç»™æ‰€æœ‰ç°æœ‰ song-input å¯ç”¨è”æƒ³ï¼ˆidempotentï¼‰
        function enableAutoCompleteForSongs() {
            const inputs = document.querySelectorAll('.song-input');
            inputs.forEach(input => {
                // rowId
                const row = input.closest('tr');
                const rowId = row ? row.id : null;
                if (!input._autocompleteWrapper) setupAutoComplete(input, () => Object.keys(lrcFiles), rowId);
            });
        }

        // ---------- å°å·¥å…· ----------
        function escapeHtml(str) {
            if (!str && str !== 0) return '';
            return String(str).replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s]));
        }

    </script>
</body>
</html>